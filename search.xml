<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bitcoin and Cryptocurrency Technologies Lecture 3 Notes]]></title>
    <url>%2F2018%2F02%2F28%2Fblockchain-lecture-3%2F</url>
    <content type="text"><![CDATA[Having a capstone project that I have to finish up and a lot of other random stuffs to deal with; was a little slow on my progress on finishing this course. Anyway, here is lecture 3. Grab the PDF version if you want better readability or archive! Mechanics of BitcoinPart 1 Bitcoin TransactionsRecap: Bitcoin consensusBitcoin consensus gives us: Append-only ledger Decentralized consensus Miners to validate transactions Assuming a currency exists to motivate miners An account-based ledger (not Bitcoin) We have to look over all transactions back there till the beginning of time to figure out if Alice has enough coins. Even if we put some data structure to keep track of Alice&#39;s balance, there is a lot more housing keeping despite the blockchain itself. So bitcoin does not use this model. An transaction-based ledger (Bitcoin) Always completely consume the input by giving an equal output. Can trace back much easier by looking at the input pointer to check if the transaction is valid Implemented with hash pointers Joint Payments​ Consume two inputs to joint pay David So needs two signatures as came from two different people Real deal: a Bitcoin transaction(very very close version) Metadata Input Output Part 2 Bitcoin ScriptsOutput “addresses” are really scripts (scriptPubKey)1234OP_DUPOP_HASH16069e02e18......OP_EQUALVERIFY OP_CHECKSIG Input “addresses” are also scripts (scriptSig)1230440220....0467d2c9.... VerificationTO VERIFY: Concatenated script must execute completely with no errors Bitcoin scripting language (“Script”)Design goals: Built for Bitcoin (inspired by Forth — an old stack-based language) Simple, compact Support for cryptography Stack-based Limits on time/memory No looping Not Turing-complete languages (As designed to prevent over-powerful miners) Example&lt;sig&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash?&gt; OP_EQUALVERIFY OP_CHECKSIG &lt;&gt; indicates data instructions If seen just push to stack Only memory interaction &lt;sig&gt; &lt;pubKey&gt; Are the signature and the public key used to generate that signature Specified by the recipient in that script sig component or input script OP_DUP make a copy of top of stack and push to stack OP_HASH160 takes the top of stack and compute a cryptographic hash of it. &lt;pubKeyHash?&gt; specified by the sender of the coins. OP_EQUALVERIFY Compare top 2 elements of the stack If false, throw error and exist Otherwise, pop top 2 elements OP_CHECKSIG Check signature of the entire transaction If true, pop the remaining elements of the stack &lt;sig&gt; &lt;pubKey&gt; Otherwise, throw error If we have no errors, we simply return True. Every Bitcoin script has only 2 outcomes: Successful or Error. If any error occurs, the transaction is invalid and should not be accepted. Bitcoin script instructions256 opcodes total (15 disabled, 75 reserved) Arithmetic If/then Logic/data handling Crypto instructions Hashes Signature verification Multi-signature verification Built-in support for joint sigatures Specify n pubKeys Speicify t — a threshold Verification requires t signatures (t of n should be valid) BUG ALERT: Extra data value posed from the stack and ignored Bitcoin scripts in practice (as of 2014) Most nodes whitelist now scripts 99.9% are simple signature checks (like shown above in example) ~0.01% are MULTISIG ~0.01% are Pay-to-Script-Hash Remainder are errors, proof-of-burn proof-of-burn is never going to redeem To write arbitrary data into the blockchain Destroy a small amount of currency to store a little bit of information on the network forever To destroy coins to get coins in the new system Pay-to-Script-HashShould senders specify scripts? As consumers we want to the transaction is easy So instead we allow pay to a hash address instead of pubKey Idea: use the hash of redemption script 123456&lt;signature&gt;&lt;&lt;pubkey&gt; OP_CHECKSIG&gt; #contains a second step that deserialized to be a script itself------------------OP_HASH160&lt;hash of redemption script&gt;OP_EQUAL Added after the original specification Benefits: Removes the complexity of sender(consumer), only needs to send to an address Efficiency gains we will talk later Part 3 Applications of Bitcoin ScriptsExample 1: Escrow Transactions PROBLEM: Alice wants to buy online fromBob. Alice doesn’t want to pay until after Bob ships. Bob doesn’t want to shop until after Alicepays. Solutions (Introduce a third party Judy with MULTISIG): Alice signs the statement: Pay x to 2-of-3 of Alice, Bob, Judy with MULTISIG IfAlice and Bob are both honest Alice and Bob together sign the statement Pay x to Bob The good thing here is Judy doesn’t need to get involved in this case Otherwise, in case someone cheated Aliceand Bob is never going to sign a statement together to pay to Bob Aliceand Bob is never going to sign a statement together to pay to Alice Now Judy comes along and decide which one has cheated Sign the payment with Bob to Bob if Judy think Alice is cheating Otherwise, Sign the payment with Alice to Alice if Judy think Bob is cheating Judy has the full power here, the nice thing here is that she only needs to get involved when there is a dispute. Example 2: Green addresses PROBLEM: Alice wants to pay bob. Bob can’t wait 6 verifications to guard against double-spends or is offline completely. Trust a third party Bank to transfer the payment Example 3: Efficient Micro-payments PROBLEM: Alice wants to pay Bob for each minute of phone service. She doesn’t want to incur a transaction fee every time. Combine small payments into a big new payment All these transactions could be double spends if signed by both Alice and Bob Bob sign only the last transaction if Bob is honest What if Bob never signs? This is when lock_time comes into play loc_time is the block index or real-word timestamp before which this transaction can’t be published, like a timed refund. More advanced scripts Multiplayer lotteries Hash pre-image challenges Coin-Swapping protocols More on this in lecture on anonymity! “Smart contracts” Part 4 Bitcoin BlocksWhy bundle transactions together Single unit of work for miners Limit length of hash-chain of blocks Faster to verify history Bitcoin block structure (high-level) Close-up look of a Block Block header Here the hash of block has to start with a number of 0s Only header is hashed during mining Only includes the root node of the Merkle tree Coinbase transaction Coinbase: a special parameter to put any arbitrary info, no limit what miners put there Part 5 The Bitcoin NetworkBitcoin P2P network Ad-hoc protocol (runs on TCP port 8333) Ad-hoc network with random topology All nodes are equal New nodes can join at any time Forget non-responding nodes after 3hr Joining the Bitcoin P2P network Find a seed node in the network Talk to seed node and request its peers Talk to those peers recursively until you have a list of nodes to connect to Will end up with a random set o nodes connected to Transaction propagation (flooding) Each node has a pool of transactions they heard about Suppose node 4 heard a transaction From Alice to Bob Node 4 talks to its peers and this is carried on recursively It won’t loop around the network forever as transaction can be uniquely identified by hash This is often referred as the gossip protocol Node: should I relay a proposed transaction? Transaction valid with current blockchain (default) script matches a whitelist Avoid unusual scripts Haven’t seen before Avoid infinite loops Doesn’t conflict with others I’ve relayed First come first served! Avoid double-spends These avoids are just sanity checks, some nodes may ignore them Nodes may differ on transaction pool (Race conditions) Transactions or blocks may conflict Default behavior: accept what you hear first Network position matters When one of the conflicting transactions made into the block then other nodes know their transactions are never going to make it to the block, they will discard it (as they are double spends now) Miners may implement other logic Stay tune for lecture on mining. Block propagation nearly identicalRelay a new block when you hear it if : Block meets the hash target Block has all valid transactions Run all scripts even if you wouldn’t relay Block builds on current longest chain Avoid forks Propagation Times Average at 30s which is really slow in Internet Node Topology is not optimized for speed Decentralized is ensured but sacrificed in terms of speed/efficiency How big is the network Impossible to measure exactly Estimates: up to 1M IP address/month Only about 5~10k full nodes Permanently connected Fully-validate Permanently connected Store entire block chain Active network to hear and forward every node/transaction Tracking the UTXO set Stands for Unspent Transaction Output Everything else can be sorted on disk Currently ~12M UTXOs Out of 44M transactions Small enough to fit into RAM (less than 1GB for now) This number is dropping Vast majority are instead lightweight nodes, or simple payment verification clients (often referred as Thin/SPV clients ) Some personal wallet can just be simple payment verification clients, only checking if transactions coming to you are valid Store block headers only Request transactions as needed To verify incoming payment Trust fully-validating nodes Not bad security tradeoff As miners will always make sure the node is valid so it has a chance to get included in the main chain 1000x cost savings (23MB v.s. 20GB) Size of entire blockchain is about 20GB Part 6 Limitations &amp; ImprovementsHard-coded limits in Bitcoin 10 min average creation time per block 1M bytes in one block 20,000 signature operatios per block These affect enomoic balance of power too much to change now, even though it might not be a wise choice. 100M satoshi per bitcoin (1 bitcoin can be divided into the 100M of smaller units called satoshi) 21M total bitcoins maximum mining reward of $\frac{50}{n^i}$ bitcoins where $i$ increases every 4 years Throughout limits in Bitcoin 1M bytes/block (10min) > 250 bytes per transaction 7 transactions per sec (which is a really small volume) compare to VISA: 2000~10000 transactions per sec Paypal: 50~100 transactions per sec Cryptographic limits Only 1 signature algorithm (ECDSA/P256) Hardcoded hash functions Crypto primitives might break by 2040 “Hard-forking” changes to Bitcoin Def: So what would it look to make a change like this where we just said, we had a problem with Bitcoin, we’re going to release a new version of the software, and everybody is going to have to switch. This is referred as a hard-forking change. We can’t be sure that every node in the network would upgrade Some nodes might refuse the new block and hence creates a diverge Soft forks Observation: we can add new features which only limit the set of valid transactions. i.e. only more strict and limiting rules Need majority of nodes to enforce new rules Old nodes will approve. Risk: old nodes might min now-invalid blocks which will be rejected by the network Soft fork example: pay to script hash Soft fork possiblities New signature schemes Extra per-block metadata Shove in the coinbase parameter Commit to UTXO tree in each block Hard forks New op codes Changes to size limits Changes to mining rate Many small bug fixes Currently seem very unlikely to happen, but will get solved in other alternative coins! Human Beings aren’t Bitcoin nodes How do people interact with the network? How do people exchange bitcoins for cash? How do people securely store bitcoins? Currency needs to work for people, not for nodes or softwares.]]></content>
      <tags>
        <tag>Bitcoin</tag>
        <tag>Blockchain</tag>
        <tag>Consensus</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitcoin and Cryptocurrency Technologies Lecture 1&2 Notes]]></title>
    <url>%2F2018%2F02%2F13%2Fblockchain-notes-1%2F</url>
    <content type="text"><![CDATA[This notes is written as my personal lecture notes taken down from the awesome lecture “Bitcoin and Cryptocurrency Technologies” provided by Princeton University on Coursera. Hope you guys find it helpful in your learning! Grab the PDF version if you want better readability or archive! Lecture 1 Basic Cryptography relatedPart 1 Hash functionHash function: Takes any string as input fixed-size output (256bits is what we use) efficiently computableSecurity Properties of Hash function collision-free Idea: Nobody can find a pair $x,y$ s.t. $x \neq y$ yet $Hash(x) = Hash(y)$ Collisions do exist Easy to illustrate, take our 256 bits hash function as example: there are only $2^{256}$ outputs and undefined arbitrarily large amount of input strings. There has to be collisions. So the key is to avoid regular people to find these collisions Ways to find collisions Try $2^{130}$ randomly chosen inputs, there are $99.8\%$ chance that two of them collide. But this takes too long to matter. No hash functions up to now has been proven to be collision-free, it’s just too hard to find a collision so we believe it as collision-free Application of collision-free: Hash as message digest If we know $H(x) = H(y)$, we can say $x=y$ as we believe $H$ is collision-free So we can use it as a tool to compare large objects like files. Instead of comparing the whole file, we can just compare their hash which is significantly smaller. (In fact, md5 is used to verify file integrity) hiding Given $H(x)$, it is infeasible to find $x$. No value of $x$ that is particularly likely. Set of value $x$ has to be very sparse. Concatenate $x$ with another value $r$ which is from a very sparse set (or $r$ is chosen from a probability distribution that has high min-entrophy) to sovle this problem.High min-entropy means that the distribution is very spread out, so that no particular value is chosen with more than negligible probability. Then given $H(r \mid x)$, it is infeasible to find $x$. Application: Commitment 12345678910111213141516(com, key) := commit(msg)match := verify(com, key, msg)To seal msg in envelope: (com, key) := commit(msg) #then publish comTo open envelope: publish key, msg anyone can use verify to check its validity #Implementation:commit(msg) := (H(key|msg), key) where key is a random 256-bit valueverify(com, key, msg) := (H(key|msg) == com)#To have such security properties: Hiding: given (H(key|msg), infeasible to find msg Binding: Infeasible to find msg != msg&apos; s.t. that (H(key|msg) == H(key|msg&apos;) puzzle-friendly For every possible output value $y$, if $k$ is chosen from a distribution with high min-entropy, then it is infeasible to find $x$ s.t. $H(k\mid x) = y$ Application: Search puzzle 1Given a &apos;puzzle ID&apos; id(from high min-entropy distrib) and a targe set Y, try to find a &apos;solution&apos; x s.t. H(id | x) in Y. Example: SHA-256 hash function Algo walkthrough: Take the original message and divide it up in chunks of 512bits​ size. The last block is padded with how many bits are there in the block and 0s to fill it up to 512bits​. After the message is partitioned, we take the IV key which is a 256bits string and concatenate with the first chunk of message block_1 to be a 768bits message chunk. Run this message chunk thru the compression algorithm c to produce a new 256bits key and pass into the next execution with message block_2 Repeat until no blocks left; return hash. Th. If c is collision-free, then SHA-256 is collsiion free. Part 2 Hash pointersHash pointer Pointer to where some info is stored and cryptographic hash of the info just like normal pointers, but not only where it is stored but also the hash of its data With hash pointer, we can ask to get the info back certify that it hasn’t changed Key idea: Build data structure with hash pointersExample: Linkedlist with Hash pointers (blockchain) we can build temper-evident log (If someone mess with data earlier we can detect it) Example: binary tree with hash pointers (Merkle tree) Advantages: Holds many items but only need to remember the root hash Can verify membership in $O(\log n)$ time Variant: sorted Merkle tree (binary search tree with hash pointers) can verify non-membership in $O(\log n)$ time (Prove nothing in between) Generally Can use hash pointers in any pointer-based data structure that has not cycles Part 3 Digital SignaturesFeatures of Signatures Only you can sign, but anyone can verify Signature is tied to particular document; can’t be copy-and-pasted to another document API for digital signatures123(sk, pk) := generateKeys(keysize)sig := sign(sk, message)isValid := verify(pk, message, sig) Requirements for signatures Valid signatures verify verify(pk, message, sign(sk,message)) == true Can’t forge signatures Adversary who knows pk gets to see signatures on messages of his choice can’t produce a verifiable signature on another message Practical stuff Algorithms are randomized good source of randomness required Limit on message isze fix: use Hash(message) rather than message Fun trick: sign a hash pointer signatures covers the whole structure (sign the entire content) Bitcoins uses ECDSA(Elliptic Curve Digital Signature Algorithm) standard relies on extremely complicated maths good randomness is extremely essential for ECDSA Part 4 Public Keys as IdentitiesUseful trick: pulic key == an identity if you see sig s.t. verify(pk, msg, sig) == true , In order to speak as pk, you need to have the matching private key sk. How to make a new identity create a new random key-pair (sk, pk) pk is the pubic “name” you can use, normally H(pk) as pk is large sk let’s you speak as pk you control the identity because only you know sk if pk looks random, nobody needs to know who you are Decentralized identity management No need to use username, etc anyone can make a new identity anytime and make as many as wanted no central point of coordination these identities are called address or wallet_address in Bitcoin Privacy (how private it is) Addresses not directly connected to real-word identity But observer can link together an address’s activity over time, make inferences Will talk this later Part 5 A simple CryptocurrencyGoofy Coin: Simplest CryptocurrencyRules: Goofy can create new coins that belongs to him CreateCoin[uuid] singed by pk_goof A coin’s owner can spend it make a statement pay to pk_alice with hash pointer signed by pk_goofy The recipient can pass on the coin again Problemsdouble-spending attack (one of the major design challenges) both Bob and Chuck has a valid claim on the coin Scrooge CoinChanges on top of goofy coin Scrooge publishes a history of all transactions(a blockchain signed by Scrooge) Optimization: put multiple transactions in the same block Now everyone can detect double-spending New CreateCoins transaction New PayCoin transaction: consumes some coins and creates new coins of the same total value Valid if consumed coins valid not already consumed total value out = total value in signed by owners of all consumed coins New Immutable Coin Coins can’t be transferred, subdivided, or combined But you can achieve the same effect by using transactions to subdivide Create new trans that consume your coin and pay out two new coins to yourself with a same total value Problem: Centralization Scrooge can be misbehaving Scrooge have to operate his functions all the time how to operate without any central, trusted party Problems to solve: If we can solve all of these problems, then we can build a currency that is very much like BitCoin. Which is like ScroogeCoin but without a centralized party. How everyone can agree upon a single published block chain that is the agreed upon history which transactions have happened? How people can agree which transactions are valid and which transactions have actually occurred? How we can assign IDs to things in a decentralized way? Assignment: Scrooge Coin’s public ledgerLecture 2 How Bitcoin achieves DecentralizationPart 1 Centralization vs. DecentralizationDecentralization is not “all-or-nothing” Email: Decentralized protocol (smtp), but dominated by centralized webmail services(gmail, outlook). Questions to answer about decentralization in Bitcoin Who maintains the ledger? Who has authority over which transactions are valid? Who creates new bitcoins? Who determines how the rules of the system change? How do bitcoins acquire exchange value? Beyond the protocol: Exchanges Wallet software Service providers Aspects of decentralization in Bitcoin P2P (Peer-to-Peer) Network Open to anyone, low barrier to entry Mining Open to anyone, but inevitable concentration of power often seen as undesirable. Mainly due to the computing resource required to solve hard computational problem Updates to software Core developers trusted by community, they have a lot of power Part 2 Distributed ConsensusBitcoin’s key challenge: Distributed ConsensusWhy consensus protocols? Traditional motivation: reliability in distributed systems. e.g. Possible database inconsistency issue Distributed K-V store: enables various applications like DNS, public key directory, stock trades Defining Distributed Consensus The protocol terminates All correct nodes decide on same value This value must have been proposed by some correct nodes Bitcoin is a peer-to-peer system When Alice wants to pay Bob:She broadcasts the transaction to all Bitcoin nodes Alice’s Signature Bob’s pubkey Hash: hash pointer to the “history” of this coin Bob’s computer is not in the picture bitcoin is his no matter if he knows Order of transaction sequence Which nodes receive the broadcast How consensus “could“ work in Bitcoin At any given time: All nodes have a sequence of blocks of transactions they’ve reached consensus on. Each node has a set of outstanding transactions it’s heard about Why consensus is hard (technically) Nodes may crash Nodes may be malicious Network is imperfect Not all pairs of nodes connected Faults in network Latency No notion of global time Not all nodes can agree to order of events by looking at timestamps, can’t determine which transaction happens first Many impossibility results Byzantine generals problem How the Byzantine General Sacked the Castle: A Look Into Blockchain The Byzantine Generals’ Problem Byzantine General’s Problem Paper by EECS Berkeley Fischer-Lunch-Paterson (deterministic nodes) Consensus impossible with a single faulty node Well-known protocols to solve this problems Paxos Never produces inconsistent result Can (rarely) get stuck, fail to make any progress Understanding impossibility results These tests are developed around the concept of distributed databases, not necessarily bitcoin Bitcoin consensus works better in practice than in theory Theory is still catching up But theory is important as it can help predict unforeseen attacks Some things Bitcoin does differentlyBitcoin does not quite solve Distributed Consensus Problem in a general sense, but solves it in the context of a currency system. Introduces incentives Possible only because it’s a currency Embraces randomness Does away with the notion of a specific end-point Consensus happens over long time scales — about 1 hour But even at the end of that time, you’re not a 100% sure that a transaction or a block that you’re interested in has made it into the consensus block chain. Instead, as time goes on, your probability goes up higher and higher. And the probability that you’re wrong in making an assumption about a transaction goes down exponentially. So that’s the kind of inherently probabilistic guarantee that Bitcoin gives you. And that’s why it’s able to completely get around these traditional impossibility results on distributed consensus protocols. Part 3 Consensus without Identity: the Block ChainWhy identity? Pragmatic: some protocols need node IDs Security: assume less than 50% malicious Why don’t Bitcoin nodes have identities? Identity is hard in a P2P system — Sybil attack Pseudonymity is a goal of Bitcoin Weaker Assumption: select random node Analogy: lottery or raffle When tracking &amp; verifying identities is hard, we give people tokens. tickets, etc Now we can pick a random ID &amp; select that node Key idea: implicit consensus In each round ,random node is picked This node proposed the next block in the chain Other nodes implicitly accept/reject this block by either extending it or ignoring it and extending the chain from earlier block Recall every block contains hash of the block it extends Bitcoin consensus algorithm (simplified) New transactions are broadcast to all nodes Each node collects new transactions into a block In each round, a random node gets to broadcast its block Other nodes accept the block only if all transactions in it are valid(unspent, valid signatures) Nodes express their acceptance of the block by including its hash in the next block they create Why this works by looking at what can a malicious node do? Attackers can’t steal bitcoins belong to others. As she can’t forge their signatures. As long as the crypto is solid, this is impossible. Attacker can deny service to some user. But this is minor as nodes are selected at random to propose its block. Some honest node will propose its correct block sometime afterwards. Attackers can start double-spending attacks. How to prevent double spending in blockchain?A valid transactionSuppose this is Alice is buying some merchant from merchant Bob and the payment is done with Bitcoin. A valid transaction could look like this: Alice is paying Bob with a bitcoin $C_A$ signed by Alice and paid to the merchant Bob’s public key(address) There are actually at least two types of pointers in this graph The Hash pointer from a block to its previous block indicating where it extends from The Hash pointer of this coin/transaction to its previous transaction(where the coin came from) Recall Bitcoin is represented by a transaction Intuitively, a coin has a log of how it’s transferred around the network There’s also a third pointer in this graph called Merkle Trace which we are not discussing right now. This is the blockchain right now. So as far as Bob is concerned, he saw the transaction is completed and added to the chain, he may allow Alice to receive her goods in exchange for her bitcoin payment. But this opens up vulnerability to double-spending attack. A double-spending attack If by random, Alice get to propose the next block; Alice could propose a new block that looks like above. Ignore altogether the valid block on that contains the transaction to Bob. And instead, contains a pointer to the previous block instead a pointer to the valid block. In addition, it contains a transaction that has a transfer of coins, from Alice but not to Bob. Instead, it transfers to A&#39; which is another address controlled by Alice. This is a classic double spending pattern. What is going on here, is Alice now creates a new transaction that transfers that coin, instead of to Bob’s address, to another address owned by her. This is a completely different transaction, also with the same Hash Pointer going back to the same transaction referred earlier in the transaction to Bob. How do we know if this double-spending attack is going to succeed or not? Depends on which one of the green transaction and the red transaction is going to end up in the long-term consensus chain. Consensus Rule for honest nodes: Honest node always follow the policy of extending the longest valid branch. From a moral point of view, the green on is definitely the longest valid branch for other nodes to follow. However, from a technical perspective, these two transactions are completely identical in validity. The nodes really have no way to tell which one is the “legitimate” transaction. (“legitimate” here is a moral judgement that we apply to it, so it’s not a technical distinction) Nodes often follow a heuristic of extending the block that they first heard about on the peer-to-peer network, but it’s not a solid rule. And in any case, because of network latency, that could easily be the other way around. So if Alice get to propose the block contains the red transaction, it could get included into the consensus chain and becomes the longest valid chain. Even if some other node gets to propose, she could potentially hack/bribe to achieve her goals. So if Alice succeeded, her branch becomes the longest valid branch. Honest nodes will be more likely to add more blocks to Alice&#39;s branch and it will become more and more valid. At this point, Alice has succeeded her double spending attack. Her fraudulent transaction is successfully buried deep in the consensus chain. How a Merchant like Bob can prevent this? From Bob’s perspective he could confirm the transaction is successful on different circumstances. He could confirm the transaction as long as it gets broadcasted. This is more foolhardy than our example above. This is called 0 confirmations. He could wait along and wait for 1 block with the successful legit transaction to be added to the consensus chain. This is called 1 confirmations. He could wait even longer, like 3 confirmations. Because the node to propose is selected at random. It’s incredibly hard for Alice to build a faulty chain with the same length as the legit chain. She would have to possess more and more malicious nodes to make her chain even 1 block longer. Based on the sense that most nodes are honest the fact longer the chain is after the green transaction, harder to produce fraudulent chain The double-spend probability decreases exponentially with number of confirmations. The most common heuristic among the bitcoin community agrees upon 6 confirmations as being enough. There is nothing really special about the number six. It’s just a good trade-off between the amount of time you have to wait and your guarantee that the transaction you’re interested in ends up on the consensus block chain. Recap Protection against invalid transactions is cryptographic, but enforced by consensus. Protection against double-spending is purely by consensus. Cryptography has nothing to say about this. You are never 100% sure that a transaction that you’re interested in is on the consensus branch. But this exponential probability guarantee is pretty good. After about six transactions, there’s virtually no chance that you’re gonna go wrong. Part 4 Incentives and Proof of WorkAssumption of honesty is problematic Nodes have financial incentives to subvert the protocols for their own gains Can we give nodes incentives to behave honestly? Penalize nodes that create problematic blocks? Nodes don’t have identity, no way to chase them and penalize Can we reward nodes that create valid blocks? Yes. Incentives in BitcoinIncentive 1: Block rewardCreator of block gets to include special coin-creation transaction in the block choose recipient address of this transaction Value is fixed: currently 25 BTC, halves every 4 years (currently phase 2) Bitcoin supply The slope of the supply curve halts every 4 years This ends up as a geometric sequence with a final finite sum Bitcoin is only created this way(reward for building new blocks that ends up in the consensus chain) Block creator gets to “collect” their rewards only if their block ends up on the long-term consensus branch. (The coin creation transaction is only valid if it ends up on the long-term consensus branch) Incentive 2: Transaction value Creator of transaction can choose to make the output value less than input value Remainder is a transaction fee and goes to block creator Purely voluntary, like a tip How the environment will evolve is interesting game theory Remaining problems How to pick a truly random node? How to avoid a free-for-all due to rewards? (Everyone runs a block try to get the block creation reward) How to prevent Sybil attacks? One same solution to these remaining problems?To approximate selecting a random node: select nodes in proportion to a resource that no one can monopolize(we hope) Resource choices: Select a node in proportion to computing power: proof-of-work Select a node in proportion to ownership of the currency: proof-of-stake Proof-of-work (Intentions) Allow nodes to compete with each other with their computing power, result in nodes automatically getting picked in proportion to their computing power Make it moderately hard to create new identities(nodes) Hash puzzles To create block, it is required to find a nonce s.t. H(nonce|prev_hash|tx|tx|....|tx) is in a very small subset of the entire output space of the hash function Therefore, if our hash function is secure enough: only way to succeed is to try enough nonces until you get lucky. Thus we made it moderately difficult to create new blocks. Completely does away with the requirement for somebody somehow to pick a random node. Instead, nodes are simply all the time independently competing to solve this puzzle. Once in a while, some node will get lucky and find a valid nonce and that node gets to propose the next block. PoW propertiesProperty 1: difficult to compute As of Aug 2014: about $10^{20}$ hashes per block, this is a humongous number So only some nodes bother to compete — miners Property 2: parametrizable cost Nodes automatically recalculates the target space of PoW every two weeks based on the entire network’s global computing power s.t. a fixed rate output of blocks Goal: Average time between block creations = 10 minutes, a efficiency concern Prob(alice wins next block) = fraction of global hash power she controls Key security assumption: Attacks infeasible if majority of miners weighted by hash power follow the protocol (aka honest) Property 3: trivial to verify nonce must be published as part of the block So other miners can verify that H(nonce|prev_hash|tx|tx|....|tx) in target Part 5 Putting It All TogetherMining EconomicsComplications: Fixed vs. variable costs Reward depends on global hash rate Also exchange value of rewarded bitcoin in terms of dollars for example is fluctuating Whether profitable is a very complicated game theory problem Recap Identities: Any time any user can make any number of pseudonymous key pair as identities. Transactions: Basically messages that are broadcast to the bitcoin p2p network. Which are instructions to transfer a coin from one address to another. Coin: Really is just a chain of transactions. P2P network: Goal: propagate all new transactions to all the Bitcoin peer nodes as well as new blocks to the Bitcoin peer nodes. The real security of the system doesn’t come from the perfection of the P2P network. Nevertheless, the underlying assumption is that the network is quite unreliable. Security comes from blockchain and consensus protocol. Block chain &amp; consensus Protocol Your transaction to be in the block chain is that it achieves a lot of confirmations. It’s not a fixed number, 6 is a commonly used heuristic, but the more confirmations your transaction has received, the more blocks are found that extend the block that contained your transaction, the more certain you can be that your transaction was part of the consensus chain. A variety of orphan blocks, blocks that don’t make it to the consensus chain. Can be interpreted as different possibilities: An invalid transaction A double-spend attempt A network latency residue (t could simply represent the fact that there is latency in the network, and two miners competing to solve this proof of work puzzle. Simply ended up finding new blocks within just a few seconds of each other. And, so both of these blocks were broadcast nearly simultaneously onto the network. ) Hash puzzles &amp; mining So another subtle point here is that if Alice and Bob were two different miners, and Alice has 100 times as much computing power as Bob. What that means is, not that Alice will always win the race against Bob to find the next block, but instead, Alice and Bob have a ratio, a probability ratio, of finding the next block in the proportion 100 to 1. So in the long term Bob will find, on average, 1% of the blocks that Alice does. Miners are a special type of nodes that bother to compete in this game of creating new blocks and they’re rewarded for their efforts in terms of Bitcoins. And we expect that miners are going to be typically somewhere near the economic equilibrium of the expenditure that they incur, in terms of hardware and electricity, being somewhere equal to the rewards that they obtain in terms of the new block creation reward and the transaction fee based rewards. Bitcoin has three types of consensus Value Like exchange rate in fiat currencies State (blockchain) Which transaction are valid Which transaction actually happened Ownership of bitcoin is based on consensus (other nodes think someone owns it) Rules (of the system) When the rule of system needs to change Soft forks Hard forks Bitcoin is bootstrapped Let’s start from the security of the block chain. So obviously we want the block chain to be secure for Bitcoin to be a viable currency. But, what is necessary for the block chain to be secure? What this means is that an adversary shouldn’t be able to overwhelm the consensus process. Shouldn’t be able to create a lot of nodes and take over 50% or more of the new block creation. But a prerequisite for that is a healthy mining ecosystem made up of largely honest protocol following nodes. So that’s a prerequisite for security of the block chain. But miners are only incentivized to mining if the exchange rate of Bitcoin is pretty high. But what ensures a high and stable value of the currency? That can only happen if, users in general, people who want to buy Bitcoins, have trust in the security of the block chain. Because if they believe that the network could be overwhelmed at any moment by an attacker then Bitcoin is not going to have a lot of value as a currency. So there is this interlocking interdependence between these three things. What can a “51% attacker”(Consensus Suberter) do? Steal coins from existing address? Not possible. Even if the invalid branch makes it self the longest branch. Honest nodes will not approve and keep on mining valid blocks. Creating a fork in blockchain. A merchant running a honest node can simply ignore the longest branch as it contains a invalid transaction. (crypto and signature don’t checkout) Only if subverting both consensus and cryptography will succeed. Suppress soem transactions? From the blockchain Possible Since he controls the consensus, he can skimpy refuse any new blocks contain that transaction also refuse build upon blocks that contain such transactions. From the P2P network Impossible Assume the attacker doesn’t fully control the network, can’t prevent transaction being broadcasted to the network Change the block reward (Rule of the system) Impossible Doesn’t control the source software every node is using. Destroy the confidence of Bitcoin Possible Main practical attack Remaining questions How do we get from consensus to currency? What else can we do with consensus?]]></content>
      <tags>
        <tag>Bitcoin</tag>
        <tag>Blockchain</tag>
        <tag>Consensus</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 101 and How It's Different From VPN]]></title>
    <url>%2F2017%2F09%2F05%2Fshadowsocks-intro%2F</url>
    <content type="text"><![CDATA[There is no perfect tool. BriefVPN (aka Virtual Private Network)The purpose of VPN is to build a Private Network over the Public Network for encrypted communication purpose and is widely used in Enterprises initially. VPN gateway essentially works by encyprting data packets and changing the destination of data packets to achieve remote access. VPN has many different forms, mainly differentiated by the protocol they use, such as PPTP, L2TP, OpenVPN, etc. Shadowsocks (aka Socks5 Proxy)Socks is a circuit-level gateway which is quite low-level. It is developed by David Koblas in 1990 and used as the open standard for Internet RFC ever since. Socks is not restricted to certain OS, unlike HTTP Proxy and application layer proxy. Socks Proxy merely transfer data packet and does not care about which protocol is used, which makes it much master than application layer proxy Summary VPNLike its name, you are connected to a private network and all your access to Internet goes out from this Private Network. You will probably be assigned a private IP address just like you are assigend a public IP by your ISP. Socks5 ProxyIt just builds a tunnel between you and the proxy server and put all your network request thru this tunnel. And let the proxy server transfer your request for you to the destination. You never entered any new network. And the proxy server also handles the resposne from the destination and transfer that back to you. There is no further modificaiton of the data. If your data is encrypted originally, it’s secure. It’s like UPS/Fedex, you want to send a package to your friend, you let Fedex to ship it for you. And when your friend are ready to ship something back to you, he/she will give it to Fedex and let them give back to you. Design Concepts VPN iks developed for secure data transferring inside a Enterprise private network. And what matters the most is security. However, it is easy to identify VPN data flow; which makes it really vulnerable to the GFW. Because of this PPTP is banned in most regions L2TP also experience interference and disconnect in most regions OpenVPN is banned as well. IKEv2 is not banned but the GFW has started to perfrom middle-man attack on it. Thus, VPN is really struggling with GFW. Shadowsocks is developed to pennetrate the GFW, deliberately made inefficient and difficult for the GFW to spot and block. Which makes it a way better tool to penetrate the GFW. In conclusion, Shadowsocks emphasizes anti-disturbance and anti-interference; while VPN emphasizes security. For example, the most secure VPN protocol OpenVPN is the first to be banned by GFW. There is no perfect tool. To some extent, you can say VPN and Shadowsocks are totally different technologies. Appendix GFW refers to Great Fire Wall which is a censorship agent in China dedicated to ban information on the Internet which the Party doesn’t want you to access.]]></content>
      <categories>
        <category>GFW</category>
      </categories>
      <tags>
        <tag>GFW</tag>
        <tag>ss</tag>
        <tag>Socks5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Enable Https for You Website (Apache and Ubuntu)]]></title>
    <url>%2F2017%2F09%2F05%2Fhow_to_enable_https(ssl)_for_your_website%2F</url>
    <content type="text"><![CDATA[PrefaceHttps is becoming more of a common standard these days. Without using an encrypted HTTPS connection opens up your server to a man-in-the-middle (MITM) attack, and risks the interception of user data and passwords. It is a best practice, and highly recommended, to always use HTTPS on production servers, and to never allow unencrypted HTTP. Apache2 comes with built-in ssl module which is very easy to configurate. This Guide is tested with Apache2 and Ubuntu 16.04 64bits Update Apache2 FirstI recommend upgrade your apache to this build which comes with HTTP2. HTTP2 has huge speed improvements over HTTP with multiple request. Most browsers already support HTTP2 over SSL (HTTPS). 123456$ sudo add-apt-repository -y ppa:ondrej/apache2$ sudo apt-key update$ sudo apt-get update$ sudo apt-get --only-upgrade install apache2 -y$ sudo a2enmod http2$ sudo systemctl restart apache2 Enable SSL First we need to enable ssl module of Apache2. 12$ a2enmod ssl$ sudo systemctl restart apache2 Then we need to edit the content of our default-ssl.conf config file. We will make a copy of the default config instead. 12$ sudo cp default.conf mysite.conf$ sudo nano mysite.conf We will need to edit these two lines in Nano to put our own ssl certificate. 12SSLCertificateFile /path/to/your/certSSLCertificateKeyFile /path/to/your/key We will use Let’s Encrypt’s Free SSL certificate. Go to their certbot page. and choose your own server configuration. Here we will do Apache and Ubuntu 16.04. Follow the installation instruction should be good enough. 123456789101112### Install Certbot$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install python-certbot-apache# Produce Key and modify apache default config$ sudo certbot --apache# If you want to modify the config yourself, just do$ sudo certbot --apache certonly After adding your cert to Apache2 config, open up your config file again and append a header to further improve security. 123456$ sudo nano mysite.conf #and add this lines in the VirtualHost tags&lt;IfModule mod_headers.c&gt; Header always set Strict-Transport-Security "max-age=15552000; includeSubDomains"&lt;/IfModule&gt;· We are almost finished! One more step is to redirect all traffic to our HTTPS protocol instead. This is actaully easy. Just add these lines to a new config file (or you can add to your existing config): 123456789$ sudo nano redirect.conf#add these linesNameVirtualHost *:80&lt;VirtualHost *:80&gt; ServerName yourdomain DocumentRoot /var/www/yourdir Redirect permanent / https://yourdomin&lt;/VirtualHost&gt; Now we are finished. Just enable the configs and restart apache. 123$ sudo a2ensite mysite.conf$ sudo a2ensite redirect.conf$ sudo systemctl restart apache2 Ref CertBot NextCloud 12 Hardening and Security Guidance]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Apache2</tag>
        <tag>Web Server</tag>
        <tag>HTTPS</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unlock China-Only Access Restriction PAC解除地区限制(网易云音乐, Bilibili番剧等)]]></title>
    <url>%2F2017%2F09%2F03%2Fanti-music163-pac%2F</url>
    <content type="text"><![CDATA[Update Update 09/05/2017 Found a solution with Unblock Youku’s DNS server instead to unlock more apps. (Sometimes won’t work on desktop, use Unblock Youku’s chrome extension instead) This method has been tested work with: Bilibili WebApp and Bilibili iOS App to view Bilibili Bangumi (Bilibili正版番剧) Netease WebApp(music.163.com) (Stable on mobile, Not on Desktop), doesn’t work with the iOS app. PrefaceA lot of Chinese enjoy music of their own languages which are rarely accessible on spontify, pandora, or any other online music stream service not based in China. However, most companines offering music streaming service in China (like Netease, Tencent, Xiami) blocks foreign IPs for some complicated reasons. Among them, Netease is probably the most popular one among Chinese students abroad. So an easy one to regain access is very much needed. How to (MAC)? Open system preference. Open Network. Click Advanced tab in the corner. Choose proxy tab. Choose Automatic Proxy Configuration (The second item on the list). Add http://xiax.ai/pac/mobile.pac to the URL field. Should look like this screenshot. Then click ok to go back. Click apply. Go to music.163.com and start streaming! How to (iOS)? Open Settings Click a the information icon on the Wi-Fi you are using. Turn on proxy by activating the auto tab under proxy. Add the PAC_URL (http://xiax.ai/pac/mobile.pac) to the field. Go back and stream! Caution Note this will not work when Unblock Youku’s proxy server is down. Just wait and try later. Or you can setup your own shadowsocks server instead. I will have a new tutorial for this in the next couples days. Leave a comment if you have any trouble with this. I will try my best to help. Ref http://xiax.ai/pac/mobile.pac is just a mirror of http://pac.uku.im/pac.pac, in case their server under DDoS. If you want to setup your own server Offical Manual from Unblock Youku]]></content>
      <categories>
        <category>GFW</category>
      </categories>
      <tags>
        <tag>GFW</tag>
        <tag>Linux</tag>
        <tag>pac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vgg Overview and Build a Linear Model With CNN Features]]></title>
    <url>%2F2017%2F09%2F01%2FDNN-overview-and-Linear-model-with-CNN-features%2F</url>
    <content type="text"><![CDATA[PrefaceIn this article, I will go through some key maths background to understand DNN. As well as finetuning aka how to build a train a linear model on top of a existing image recogniton to our tasks.This is a study note of Fast.ai Lesson 2 . So what’s magic happening in Lesson 1?How can we just borrow the Vgg model, finetune it and it magically can distinguish cats vs dogs? Let’s start with how can Vgg recognize images. What is Vgg?Vgg is basically a DNN that is trained upon the ImageNet which is enable to classify the input into one of the 1000 categories(It actually gives probas for each categories). How it’s doing that? Although DNN is often time a black box, we can still understand parts of how it works following this paper. Generally, a Image Recognition DNN is consists of multiple layers of pattern from the very simple ones to complicated ones. The first layer might just be a gradient, a line, a diagonal, a curve, any small simple patterns like that. The second layer basically assembles patterns found in the first layer, it might recognize corner (just two connecting diagonal connected with a 90 degree angle), circule, oval now . The same logic follows on. For example, the model could identify human faces at level 5 or level 6. Here is an image taken from the paper, first 5 layers is shown along with actual images where it found a match. For example, Vgg has 16 layers. DNNSo how is Vgg doing that? No one is telling it about the patterns. This is done by the black box of DNN. A neural network is at its core a sequence of matrices that map an input vector to an output vector through matrix multiplication. The intermediate vectors in between each matrix are the activations, and the matrices themselves are the layers. Through a process we’ll learn about called “fitting”, our goal is to adjust the values of the matrices, which we call “weights”, so that when our input vectors are passed into the neural network we are able to produce an output vector that is as close as possible to the true output vector, and we do this across multiple labeled input vectors. This is what makes up a training set. Above, we started with randomly generated weights as our matrix elements. After performing all the operations and observing the outcome, notice how the activations output is significantly different than our target vector y. Our goal is to get as close to the target vector y as possible using some sort of optimization algorithm. Before using the optimization algorithm, it’s suggested to start your weight values in a manner that makes the activations output at least relatively close to the target vector. This method is called weight initialization. There are many weight initializers to choose from. In the lecture, Jeremy uses Xavier Initialization (also known as Glorot Initialization). However, it’s important to note that most modern deep learning libraries will handle weight initialization for you. Loss FunctionsSo how are we minimizing this loss function? First we need to define a loss function, there are several popular loss functions. Here I will introduce SVM(Support Vector Machine) and Softmax. SVM as Loss FunctionSVM (Multiclass Support Vector Machine loss)L_i = \sum_{j \ne y_i} max(0, s_j -s{y_i} + \Delta) j for true label class $ j \ne y_i$ for all incorrect class $s_j$ for weight of the true label class $s_{y_i}$ for weight of other incorrect class $\Delta$ for tolerence of the difference $max(0, -)$ aka hinge loss, people sometimes use squared hinge loss as $max(0, -)^2$ that penalizes violated margins more strongly. Usually linear hinge loss is good enough. In summary, the SVM loss function wants the score of the correct class $y_i$ to be larger than the incorrect class scores by at least by $\Delta$ (delta). If this is not the case, we will accumulate loss. $i.e.$ The Multiclass Support Vector Machine “wants” the score of the correct class to be higher than all other scores by at least a margin of delta. Regularization for SVMThere is a problem with this SVM loss function is that there could multiple set of $W$ that satisfies (minimizing $L$ to 0). So we want to encode our $W$ to remove this ambiguity. A standard way is to extend the loss function with a regularization penalty $R(W)$. The most common scheme for regularization penalty is $L2$ norm that discourages large weights through an elementwise quadratic penalty over all parameters as shown below: R(W) = \sum_{k} \sum_{l} W_{k, l}^2And thew new loss function $L$ now contains two parts: data loss (which is average loss $L_i$ over all samples$ and the regularization loss. That is the full Multiclass SVM loss: L = \frac{1}{N} \sum_{i }L_{i} + \lambda R(W)which can be expand to its full form as : L = \frac{1}{N} \sum_{i } \sum_{j \ne y_i} max(0, f(x_i; W)_j -f(x_i; w)_{y_i} + \Delta) + \lambda \sum_{k} \sum_{l} W_{k, l}^2And this is able to improve the generalization performance at the end lead to less overfitting. As the $L2$ penalty prefers smaller and more diffuse weight vectors so the final classifier is encouraaged to take into acocunt all input dimensions to small amounts rather than a few input dimensions and very strongly. Softmax as Loss FunctionIn a softmax classifier, the function mapping $ f(xi; W) = W{x_i} $ is unchanged, but it interprets these scores as unnormalized log porbabilities for each class and replace the hinge loss with corss-entrophy loss in the following form: L_i = -log \left(\frac{e^{f_i}}{\sum_j e^{f_j}} \right) $f_j$ is the $j_th$ element of the vector of class scores $f$. $\frac{e^{f_i}}{\sum_j e^{f_j}}$ is the softmax function, it takes over a vector of arbitrary real-valued scores and squashes it to a vector of values between zero and one that sum to one. Optimization with SGDSo with loss function, we are able to build the correlation that Better\, Prediction = Minimizing \, Loss \, FunctionSo our goal of optimization is to find $W$ which minimizes the loss function. Strategy 1: A very bad solution: Random SearchWhat should we do?Core idea: iterative refinement. Of course, it turns out that we can do much better than this random search. The core idea is that finding the best set of weights W is a very difficult or even impossible problem (especially once W contains weights for entire complex neural networks), but the problem of refining a specific set of weights W to be slightly better is significantly less difficult. In other words, our approach will be to start with a random W and then iteratively refine it, making it slightly better each time.12345678bestloss = float("inf") # Python assigns the highest possible float valuefor num in xrange(1000): W = np.random.randn(10, 3073) * 0.0001 # generate random parameters loss = L(X_train, Y_train, W) # get the loss over the entire training set if loss &lt; bestloss: # keep track of the best solution bestloss = loss bestW = W print 'in attempt %d the loss was %f, best %f' % (num, loss, bestloss) Strategy 2: Random Local Search (Slightly Better)So a little better solution is: Do the same random search but only proceed if less loss. 12345678910W = np.random.randn(10, 3073) * 0.001 # generate random starting Wbestloss = float("inf")for i in xrange(1000): step_size = 0.0001 Wtry = W + np.random.randn(10, 3073) * step_size loss = L(Xtr_cols, Ytr, Wtry) if loss &lt; bestloss: W = Wtry bestloss = loss print 'iter %d loss is %f' % (i, bestloss) Strategy 3: Following the GradientIt turns out that there is no need to randomly search for a good direction: we can compute the best direction along which we should change our weight vector that is mathematically guaranteed to be the direction of the steepest descend (at least in the limit as the step size goes towards zero). This direction will be related to the gradient of the loss function. In our hiking analogy, this approach roughly corresponds to feeling the slope of the hill below our feet and stepping down the direction that feels steepest. Computing the Gradient There are two ways of computing gradient: Numerical Gradient 1234567891011121314151617181920212223242526272829303132333435363738394041def eval_numerical_gradient(f, x): """ a naive implementation of numerical gradient of f at x - f should be a function that takes a single argument - x is the point (numpy array) to evaluate the gradient at """ fx = f(x) # evaluate function value at original point grad = np.zeros(x.shape) h = 0.00001 # iterate over all indexes in x it = np.nditer(x, flags=['multi_index'], op_flags=['readwrite']) while not it.finished:nction at x+h ix = it.multi_index old_value = x[ix] x[ix] = old_value + h # increment by h fxh = f(x) # evalute f(x + h) x[ix] = old_value # restore to previous value (very important!) # compute the partial derivative grad[ix] = (fxh - fx) / h # the slope it.iternext() # step to next dimension return grad def CIFAR10_loss_fun(W): return L(X_train, Y_train, W)W = np.random.rand(10, 3073) * 0.001 # random weight vectordf = eval_numerical_gradient(CIFAR10_loss_fun, W) # get the gradientloss_original = CIFAR10_loss_fun(W) # the original lossprint 'original loss: %f' % (loss_original, )for step_size_log in [-10, -9, -8, -7, -6, -5,-4,-3,-2,-1]: step_size = 10 ** step_size_log W_new = W - step_size * df # new position in the weight space loss_new = CIFAR10_loss_fun(W_new) print 'for step size %f new loss: %f' % (step_size, loss_new) Analytic GradientBecause of the fact numerical gradient are expensive to compute for datasets with millions of features which is very common for DNNs. ( Because each step needs to compute the gradient for each feature, so it is linear complexity). We normally use the other option: analytic gradient. In which we use a direct formula for the gradient which is way faster to compute.Suppose we have the SVM loss function for a single data point as follows: L_i = \sum_{j \ne y_i} [max(0, w_j^Tx_i - w_{y_i}^Tx_i + \Delta)]And we can differentiate the function w/ respect to weights $W$. $e.g.$, taking the gradient with respect to $w_{y_i}$ we can obtain: \nabla_{w_j} L_i = - \left( \sum_{j \ne y_i} \mathbb{1} (w_j^Tx_i - w_{y_i}^Tx_i + \Delta > 0) \right) x_iwhere $\mathbb{1}$ is the indicator function which if the condition inside is true, it evals to 1 if false, it evals to 0 The function looks confusing but at its essence, it is equivalent to: Count the number of classes that didn’t meet the desired margin $\Delta$ and scale the data vector $x_i$ by this margin. And the result is the gradient. Gradient DescentNow we can compute the gradient of the loss function, the procedure of repeatedly evaluating the gradient and then performing a parameter update is called Gradient Descent. A vanilla version looks like this:123while True: weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # This simple loop is the core of every nueural network libs. There are a few different methods of gradient descent: Batch Gradient Descent Mini-Batch Gradient Descent Stochastic Gradietn Descent Mini-Batch Gradient Descent is the mostly used one and often refered as SGD. It takes a random batch of (32, 64, 128, 256) arbitrary number of samples and compute gradient descent on it and update the parameters(weights) every time. A vanilla version looks like this: 1234while True: data_batch = sample_training_data(data, 256) # sample 256 examples weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update Backpropagation (Gradient Descent using reverse-mode autodiff)An ANN(MLP, multi-layer perceptron) is composed of a input layer and n (n $\geq$ 1) hidden layers and one final layer. Every layer except the output layer includes a bias neuron and is fully connected to next layer. When an ANN has $\geq$ 2 hidden layers, it is called a DNN. But for years people struggle to find a way to train DNN uintil backpropagation. For each trainning instance, the algorithm feeds it to the network and computes the output of every neuron in each consecutive layer. (Known as the forward pass). Then it measures the ouput error of the network and it computes how much each neuron in hte last hidden layer contributed to each output neuron’s error. It then proceeds to measure how much of these error contributions comes from the previous hidden layer. And this logic carries on until the algorithm reaches the input layer. Eventually, this reverse pass efficently measures the error gradient accross all the connection wieghts in the DNN by propagating the error gradient backward in the network. In short, for each training instance the backpropagation algorithm first makes a prediction by some scheme (the forward pass). Then it measures the error of this prediction then goes through each layer in each layer in reverse order to measure the error contribution from each connection (the reverse pass). And slightly tweaks the connection weights to reduce the error (Gradient Dscent step). The Math details is skipped here, for details checkout here: Back Propagation. The codeSo now we have a basic understanding of how Vgg works behind the scene and some fundaments about DNN. It’s time to dig what’s happening in the finetuning step. Basically, we just need to converge the 1000-categories output to our 2-categories output. How can we do that? Just apply a DNN to it: Take the 1000 categories result as an input array of shape [1000, 1]. Train a DNN to fit the [1000, 1] input to [2, 1] ouput using the training set. Remove the original 1000 categories layer and append our new layer. Checkout the Source Code here for details. Reference Fast.ai Lesson 2 CS231n Convolutional Neural Networks for Visual Recognition Visualizing and Understanding Convolutional Networks]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>Image Recognition</tag>
        <tag>Vgg</tag>
        <tag>Tutorial</tag>
        <tag>Linear Model</tag>
        <tag>Maths</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fast.ai Overview and Image Recognition With DNN]]></title>
    <url>%2F2017%2F08%2F31%2Fdeep_learning_image_recognition%2F</url>
    <content type="text"><![CDATA[PrefaceMore of a discussion of the way to teach I have recently started learning machine learning, mainly following a popular book called Hands-On Machine Learning with Scikit-Learn and TensorFlow: Concepts, Tools, and Techniques to Build Intelligent Systems by Aurélien Géron). It is a great book for a brief intro to the field of machine learning. I really recommend it if you are new and you want to have a taste of machine learning before you completely lose interest in a traditional academia approach. It is taught in a hands-on manner so you won’t get bored following the examples and practices on the book. The author also published all the IPython notebooks on a github repo to help learning. Anyway, it’s not really the focus here. Maybe I will write something about it if I have the time or energy. So I finished the first half of the book about machine learning with scikitlearn and I found the second half of the book to be really boring to follow through. The author switched his teaching style somehow and explained the material in a tedious academic approach (not that serious Maths but I got bored quickly). So I went on an adventure seeking something more hands-on and interesting and I found Fast.ai. It is a course originally developed for the Data Institute at UCSF by Jeremy Howard and Rachel Thomas. I looked around at their course website and it seemed pretty good to my needs. Every class is taught with a hands-on real world example. This should be it. And their overview video just shocked me. I thought it would be another overview video with an outrageous duration of 31 minutes. I was gonna skip thru it but I couldn’t. I got so carried along that I dropped my sandwich. What they said literally resonated with me so deeply every word was ringing in my head. I couldn’t agree more. What they basically said is that they think that the current common approach to teach machine learning is deeply flawed. It is taught in a way so it could remain in the world of the ivory tower. Is it useful to learn about all the nitty-gritty about Maths? Yes! Is it necessary for everyone? HELL NO! Then they talk about this problem’s origin. Jeremy believed that the problem is deeply rooted in our Maths education system. It is a system that designed to teach not to inspire. The teachers are trained to feed formula and equation to their students instead of picturing mathematics as an interesting and creative subject. I will skip the details here but you can read this amazing article: A Mathematician’s Lament by Paul Lockhart if you are interested in the discussion. Jeremy also points out the traditional way of teaching mathematics has a big problem of giving tiny pieces to the students and they will have to wait until they have all the pieces to say “WOW! This is so interesting, now I know why I am learning all of those stuff!”. Why not show them something amazing and they will be interested to learn more about the details instead of giving up halfway. So what he has in mind is to teach in the latter way, the interesting way. And this course is not for researchers in AI. It is designed to teach coders to use the AI tools for various purposes, really unleashing the power of it. He wants to give these tools to experts at other fields like biology, agriculture; so the experts can utilize the tool for much more pragmatic purposes. He gave two examples: He built a Deep Learning Model that has a better precision of identifying tumors than a panel of radiologists in his recent endeavor. Japanese farm owner used Deep Learning to classifying crops into different grades. I have to take this course after watching this overview. Lesson 1There is not much covered in lesson 1 really about Deep Learning, it is a general intro to all the tools and how to setup Python, Jupyter, AWS p2 instances, etc. Afterwards is a brief intro about image recognition with CNN(convolutional neural network). I learned about how to use a pre-existing model(Vgg, winner of ImageNet of 2014) to predict images and finetune the model to identify the task: tell if an image contains a cat v.s. a dog. And the homework is to get into the top 50% of Kaggle’s Dogs vs. Cats Redux: Kernels Edition Competition. He also mentioned a few learning methods like “don’t copy paste, write your own version”. For the details, check out the lesson and my copy of notes and homework: L1 Notes. Appendix You will find everything here: Lesson 1 at Fast.ai Jeremy Howard was president and chief data scientist at Kaggle. Rachel Thomas has a math PhD from Duke and was selected by Forbes as one of “20 Incredible Women Advancing AI Research.” A Mathematician’s Lament by Paul Lockhart My Learning Repo For the next blog, I will go thru the lesson 2 topics about CNN, maths of Deep Learning, and what is hidden in the finetuning of Vgg.]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>Image Recognition</tag>
        <tag>Vgg</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursive Runtime Study]]></title>
    <url>%2F2016%2F11%2F09%2FRecursive%20Runtime%2F</url>
    <content type="text"><![CDATA[Recursive RuntimeMultiple Return Recursion123456int func(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; return f(n-1) + f(n-1);&#125; Take this function as an example, what’s the runtime of this recursive function? Level # of Nodes In term of powers of 2 0 1 $2^0$ 1 2 $2^1$ 2 4 $2^2$ 3 8 $2^3$ 4 16 $2^4$ Looking at the call stack tree table, it is easy to derive $total = 2^0 + 2^1 + 2^2 + … + 2^n = 2^{n+1} -1 $ . Try to remember this pattern. When you have a recursive function that makes multiple calls, the runtime will often (but not always) look like $O(branch^{depth})$, where branches is the number of times each recursive call branches. In this case, this gives us $O(2^n$). As you may recall, the base of a log doesn’t matter for big O since logs of di erent bases are only di erent by a constant factor. However, this does not apply to exponents. The base of an exponent does matter. Compare $2^n$ and $8^n$. If you expand $8^n$, you get $2^{3n}$, which equals $2^{2n} \times 2^n$. As you can see, $8^n$ and $2^n$ are different by a factor of $2^{2n}$. That is very much not a constant factor! The space complexity of this algorithm will be $O(N)$. Although we have $O(2^n)$ nodes in the tree total, only $O(N)$ exist at any given time. Therefore, we would only need to have $O(N)$ memory available. Recursion With Iteration1234567891011121314void permutation(String str) &#123; permutation(str, "")&#125;void permutation(String str, String prefix) &#123; if (str.length() == 0) &#123; System.out.println(prefix); &#125; else &#123; for (int i = 0; i &lt; str.length(); i++) &#123; String rem = str.substring(0, i) + str.substring(i+1); permutation(rem, prefix+str.charAt(i)); &#125; &#125;&#125; How many times does permutation get called in its base case? If we were to generate a permutation, then we would need to pick characters for each “slot”. Suppose we had 7 characters in the string. In the first slot,we have 7 choices. Once we pick the letter there, we have 6choices for the next slot. (Note that this is 6 choices for each of the 7 choices earlier.) Then 5 choices for the next slot,and so on. Therefore,the total number of options is $7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1$, which is also expressed as $7!$ (7 factorial). This tells us that there are $n!$ permutations. Therefore, permutation is called $n!$ times in its base case(when prefix is the full permutation). How many times does permutation get called before its base case? But,of course,we also need to consider how many times lines 9 through 12 are hit. Picture a large call tree representing all the calls. There are $n!$ leaves, as shown above. Each leaf is attached to a path of length n.Therefore,we know there will be no more than $n \times n !$ nodes (function calls) in this tree. How long does each function call take? Executing line 7 takes O(n) time since each character needs to be printed. Line 10 and line 11 will also take O(n) time combined,due to the string concatenation. Observe that the sum of the lengths of rem, prefix, and str.charAt(i) will always be n. Each node in our call tree therefore corresponds to O(n) work. What is the total runtime? Since we are calling permutation $O(n \times n!) $ times (as an upper bound), and each one takes $O(n)$ time,the total runtime will not exceed $O(n^2 * n ! )$. Through more complex mathematics,we can derive a tighter runtime equation (though not necessarily anice closed-form expression). This would almost certainly be beyond the scope of any normal interview. Optimize Recursion Runtime By Examining 3 Fibonacci Number ExamplesNaive Example12345int fib(int n) &#123; if (n &lt;= 0) return 0; else if (n == 1) return 1; return fib(n-1) + fib(n-2);&#125; We can use the earlier pattern we’d established for recursive calls: $O(branches^{depth})$. There are 2 branches per call,and we go as deep as N,therefore the runtime is $O(2^N)$ Through some very complicated math,we can actually get a tighter runtime. The time is indeedexponential,but it’s actually closer to $O(1. 6^N)$. The reason that it’s not exactly $O(2^N)$ is that, at the bottom of the call stack,there is sometimes only one call. It turns out that a lot of the nodes are at the bottom (as is true in most trees), so this single versus double call actually makes a big difference. Saying $O(2^N)$ would suffice for the scope of an interview,though (and is still techni­cally correct, if you read the note about big theta on page 39). You might get “bonus points” if you can recognize that it’ll actually be less than that. Generally speaking, when you see an algorithm with multiple recursive calls, you’re looking at exponential runtime. Iteration ExampleThe llowing code prints all Fibonacci numbers from Oto n. What is its time complexity? 1234567891011void allFib(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; System.out.println(i + ": " + fib(i)); &#125;&#125;int fib(int n) &#123; if (n &lt;= 0) return 0; else if (n == 1) return 1; return fib(n-1) + fib(n-2);&#125; Many people will rush to concluding that since fib(n) takes $O(2^n)$ time and it’s called n times, then it’s $O(n{ \times 2^n})$. Not so fast. Can you nd the error in the logic? The error is that the n is changing. Yes, fib(n) takes $O(2^n)$ time, but it matters what that value of n is. Refer to the first example, the total amount of work is: $total = 2^0 + 2^1 + 2^2 + …v + 2^n = 2^{n+1} -1 $ Therefore, the runtime to compute the first n Fibonacci numbers(using this terrible algorithm) is still $O(2^n)$. Optimized ExampleThe llowing code prints all Fibonacci numbers from Oto n. However, this time, it stores (i.e., caches) previ­ously computed values in an integer array. If it has already been computed, it just returns the cache. What is its runtime? 123456789101112131415java allFib(int n) &#123; int[] memo = new int[n + 1]; for (int i = 0; i &lt; n; i++) &#123; System.out.println(i + ": " + fib(i, memo)); &#125;&#125;int fib(int n, int[] memo) &#123; if (n &lt;= 0) return 0; else if (n == 1) return 1; else if (memo[n] &gt; 0) return memo[n]; memo[n] = fib(n-1, memo) + fib(n-2, memo); return memo[n];&#125; Let’s walk through what’s going on: 123456789101112131415161718fib(l) -&gt; return 1fib(2) fib(l) -&gt; return 1 fib(0) -&gt; return 0 store 1 at memo[2]fib(3) fib(2) -&gt; lookup memo[2] -&gt; return 1 fib(l) -&gt; return 1 store 2 at memo[3]fib(4) fib(3) -&gt; lookup memo[3] -&gt; return 2 fib(2) -&gt; lookup memo[2] -&gt; return 1 store 3 at memo[4]fib(5) fib(4) -&gt; lookup memo[4] -&gt; return 3 fib(3) -&gt; lookup memo[3] -&gt; return 2 store 5 at memo[5]... At each call to fib(i), we have already computed and stored the values for fib(i-1) and fib(i-2).We just look up those values, sum them, store the new result, and return. This takes a constant amount oftime. We’re doing a constant amount of work N times, so this is $O(n)$ time. ==This technique, called memoization, is a very common one to optimize exponential time recursive algo­rithms.==]]></content>
      <categories>
        <category>Technical Interview</category>
      </categories>
      <tags>
        <tag>Technical Interview</tag>
        <tag>CS</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Technical Interview Practices]]></title>
    <url>%2F2016%2F11%2F06%2FCode%20Challenges%2F</url>
    <content type="text"><![CDATA[Arrays: Left Rotation A left rotation operation on an array of size shifts each of the array’s elements unit to the left. For example, if left rotations are performed on array , then the array would become . Given an array of integers and a number, , perform left rotations on the array. Then print the updated array as a single line of space-separated integers. Problem at https://www.hackerrank.com/challenges/ctci-array-left-rotation 123def array_left_rotation(a, n, k): # a for array, n for #(elements), k for shift return a[k:] + a[:k] Strings: Making Anagrams Problem at https://www.hackerrank.com/challenges/ctci-making-anagrams Alice is taking a cryptography class and finding anagrams to be very useful. We consider two strings to be anagrams of each other if the first string’s letters can be rearranged to form the second string. In other words, both strings must contain the same exact letters in the same exact frequency For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not. Alice decides on an encryption scheme involving two large strings where encryption is dependent on the minimum number of character deletions required to make the two strings anagrams. Can you help her find this number? Given two strings, a and b , that may or may not be of the same length, determine the minimum number of character deletions required to make a and b anagrams. Any characters can be deleted from either of the strings. 1234567891011121314151617181920212223242526272829def deletion_needed_for_anagrams(word1, word2): #create an empty dictionary charMap = &#123;&#125; #loop through all letters in word1, count the frequency of each for c in word1: if c in charMap: charMap[c] = charMap[c]+1 else: charMap[c] = 1 deletions = 0 #match with the letters in word2 for c in word2: if c in charMap: if charMap[c] &gt; 0: #common letters charMap[c] = charMap[c]-1 else: #count mismatch deletions = deletions+1 else: deletions = deletions+1 #present only in word2 #If there are more characters in first word, delete them for c in charMap: if charMap[c] &gt; 0: deletions = deletions + charMap[c] return deletions Hash Tables: Ransom Note Problem at https://www.hackerrank.com/challenges/ctci-ransom-note A kidnapper wrote a ransom note but is worried it will be traced back to him. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use whole words available in the magazine, meaning he cannot use substrings or concatenation to create the words he needs. Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No.A kidnapper wrote a ransom note but is worried it will be traced back to him. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use whole words available in the magazine, meaning he cannot use substrings or concatenation to create the words he needs. Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No. 123456789101112def ransom_note(magazine, rasom): map = &#123;&#125; for word in magazine: if word in map: map[word] = map[word] + 1 else: map[word] = 1 for f in rasom: if (map[f] == 0): return False map[f] = map[f] - 1 return True Linked Lists: Detect a Cycle Problem at https://www.hackerrank.com/challenges/ctci-linked-list-cycle Detect a cycle in a linked list. Note that the head pointer may be ‘None’ if the list is empty. 12345678910111213141516171819202122232425262728293031"""A Node is defined as: class Node(object): def __init__(self, data = None, next_node = None): self.data = data self.next = next_node"""class Node(object): def __init__(self, data = None, next_node = None): self.data = data self.next = next_node def has_cycle(head): cur = head ls = [] while (cur.next is not None): if cur in ls: return True ls.append(cur) cur = cur.next return Falsedef has_cycle_better(head): d = dict() while (head is not None): if head.val in d: return d[head.val] else: d[head.val] = head head = head.next Stacks: Balanced Brackets Problem at https://www.hackerrank.com/challenges/ctci-balanced-brackets A bracket is considered to be any one of the following characters:(,),{,}, [, or ]. Two brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and (). A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ]. By this logic, we say a sequence of brackets is considered to be balanced if the following conditions are met: It contains no unmatched brackets. The subset of brackets enclosed within the confines of a matched pair of brackets is also a matched pair of brackets. Given strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, print YES on a new line; otherwise, print NO on a new line. 1234567891011def is_matched(expression): dic = &#123;'&#123;':'&#125;','[':']','(':')'&#125; lst =[] for i in expression: if i in dic.keys(): lst.append(dic[i]) elif len(lst)&gt;0 and i==lst[-1]: lst.pop() else: return False return len(lst) == 0 Implement A Queue using Two Stacks Problem at https://www.hackerrank.com/challenges/ctci-balanced-brackets 12345678910111213141516171819class MyQueue(object): def __init__(self): self.inbox = [] self.outbox = [] def peek(self): if not self.outbox: while self.inbox: self.outbox.append(self.inbox.pop()) return self.outbox[len(self.outbox)-1] def pop(self): if not self.outbox: while self.inbox: self.outbox.append(self.inbox.pop()) return self.outbox.pop() def put(self, value): self.inbox.append(value) GCD1234567891011121314def gcd(A, B): while B: A, B = B, A%B return A# orclass Solution: # @param A : integer # @param B : integer # @return an integer def gcd(self, a, b): if (b == 0): return a else: return self.gcd(b, a%b) Find max depth of a tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Definition for a binary tree nodeclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None#Recursiveclass Solution: # @param A : root node of tree # @return an integer def maxDepth(self, A): if A == None: return 0 return max(self.maxDepth(A.left), self.maxDepth(A.right)) + 1 #Iterativeclass Solution: # @param root, a tree node # @return an integer def maxDepth(self, root): if root == None: return 0 nodeStack = [root]; depthStack = [1]; maxDepth = 0; while len(nodeStack)&gt;0: node = nodeStack.pop(); depth = depthStack.pop(); maxDepth = maxDepth if maxDepth &gt; depth else depth if node.left != None: nodeStack.append(node.left) depthStack.append(depth+1) if node.right != None: nodeStack.append(node.right) depthStack.append(depth+1) return maxDepth # Testroot = TreeNode(10)five = TreeNode(5)two = TreeNode(2)four = TreeNode(4)eight = TreeNode(8)root.left = fivefive.left = twotwo.left = eightroot.right = foursol = Solution()print sol.maxDepth(root) Flatten a tree1234567891011121314151617181920# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param root, a tree node # @return nothing, do it in place def flatten(self, root): while root != None: if root.left != None: pre = root.left while pre.right != None: pre = pre.right pre.right = root.right root.right = root.left root.left = None root = root.right Validate BST12345678910111213141516171819202122232425262728""" Node is defined asclass node: def __init__(self, data): self.data = data self.left = None self.right = None"""def check_binary_search_tree_(root): """ :type root: TreeNode :rtype: bool """ stack = [] curr = root prev = None while curr or stack: while curr: stack.append(curr) curr = curr.left if stack: curr = stack.pop() if prev and curr.data &lt;= prev.data: return False prev = curr curr = curr.right return True Tries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# list_implementationclass Node(object): def __init__(self, char): self.char = char self.children = [] self.words_count = 0 def get_child(self, c): for child in self.children: if child.char == c: return child return Noneclass Trie(object): def __init__(self): self.root = Node("*") # token root char def add(self, word): current = self.root for i in word: next_node = current.get_child(i) if next_node is None: next_node = Node(i) current.children.append(next_node) next_node.words_count += 1 current = next_node def find(self, word): current = self.root for i in word: next_node = current.get_child(i) if next_node is None: return 0 current = next_node return current.words_countn = int(input().strip())tr = Trie()for a0 in range(n): op, contact = input().strip().split(' ') if op == "add": tr.add(contact) elif op == "find": print(tr.find(contact))# dictionary_implementationclass Node(object): def __init__(self, char): self.char = char self.children = &#123;&#125; self.words_count = 0 def get_child(self, c): for child in self.children: if child.char == c: return child return Noneclass Trie(object): def __init__(self): self.root = Node("*") # token root char def add(self, word): current = self.root for i in word: if i not in current.children: current.children[i] = Node(i) current = current.children[i] current.words_count += 1 def find(self, word): current = self.root for i in word: if i not in current.children: return 0 current = current.children[i] return current.words_countn = int(input().strip())tr = Trie()for a0 in range(n): op, contact = input().strip().split(' ') if op == "add": tr.add(contact) elif op == "find": print(tr.find(contact)) Merge sort to count inversions1234567891011121314151617181920212223242526272829303132333435363738def list_join(c,d): result = [] global sortCounter for i in range(0,len(c)+len(d)): if not d: result.append(c.pop(0)) continue if not c: result.append(d.pop(0)) continue if c[0] &lt;= d[0]: result.append(c.pop(0)) continue if d[0] &lt; c[0]: sortCounter += len(c) result.append(d.pop(0)) continue return resultdef merge_sort(a): if len(a) == 1: return a mid = int(len(a)/2) left, right = a[:mid], a[mid:] leftSorted, rightSorted = merge_sort(left), merge_sort(right) return list_join(leftSorted, rightSorted)def count_inversions(a): global sortCounter sortCounter = 0 merge_sort(a) return sortCounter Regular Expression Matching1234567891011121314151617181920212223242526272829303132333435363738394041# Implement regular expression matching with support for '.' and '*'.# '.' Matches any single character.# '*' Matches zero or more of the preceding element.# The matching should cover the entire input string (not partial).# The function prototype should be:# bool isMatch(const char *s, const char *p)# Some examples:# isMatch("aa","a") → false# isMatch("aa","aa") → true# isMatch("aaa","aa") → false# isMatch("aa", "a*") → true# isMatch("aa", ".*") → true# isMatch("ab", ".*") → true# isMatch("aab", "c*a*b") → truedef isMatch(s,p): if not p: return not s if p[-1]=='*': if isMatch(s, p[:-2]): return True if s and (s[-1]==p[-2] or p[-2]=='.'): return isMatch(s[:-1], p) else: if s and (s[-1]==p[-1] or p[-1]=='.'): return isMatch(s[:-1], p[:-1] ) else: return False return Falseprint(isMatch("aa","a")) #→ falseprint(isMatch("aa","aa")) #→ trueprint(isMatch("aaa","aa")) #→ falseprint(isMatch("aa", "a*")) #→ trueprint(isMatch("aa", ".*")) #→ trueprint(isMatch("ab", ".*")) #→ trueprint(isMatch("aab", "c*a*b")) #→ truea Sorting: Bubble Sort12345678910111213141516171819202122n = int(input().strip())a = list(map(int, input().strip().split(' ')))def bubble_sort(array): total_num = 0 for i in range(len(array)): num_swaps = 0 for j in range(len(array)-1): if a[j+1]&lt;a[j]: temp = a[j] a[j] = a[j+1] a[j+1] = temp num_swaps += 1 total_num += 1 if (num_swaps == 0): break return total_numnum = bubble_sort(a)print("Array is sorted in &#123;&#125; swaps.".format(num))print("First Element:", a[0])print("Last Element:", a[len(a)-1]) Sorting: Comparator12345678910111213141516171819202122232425262728from functools import cmp_to_keyclass Player: def __init__(self, name, score): self.name = name self.score = score def __repr__(self): return name + " " + str(score) def comparator(a, b): if a.score &lt; b.score: return 1 if a.score &gt; b.score: return -1 if a.name &lt; b.name: return -1 if a.name &gt; b.name: return 1 return 0n = int(input())data = []for i in range(n): name, score = input().split() score = int(score) player = Player(name, score) data.append(player) data = sorted(data, key=cmp_to_key(Player.comparator))for i in data: print(i.name, i.score) Binary Search: Ice Cream ParlorBinary Search Approach By AllisonP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.util.*;class IceCream implements Comparable&#123; public int cost; public int id; public IceCream(int cost, int index) &#123; this.cost = cost; this.id = index; &#125; @Override public int compareTo(Object o) &#123; IceCream iceCream = (IceCream) o; return this.cost - iceCream.cost; &#125; @Override public boolean equals(Object o)&#123; IceCream iceCream = (IceCream) o; return iceCream.cost == this.cost; &#125; &#125;class Solution &#123; public IceCream[] menu; public int n; public int m; public Solution(IceCream[] menu, int n, int m) &#123; this.menu = menu; Arrays.sort(this.menu); this.n = n; this.m = m; &#125; public int binarySearch(int min, int max, int search) &#123; int middle = (min + max) &gt;&gt; 1; while(min &lt;= max) &#123; // Search value is found if( menu[middle].cost == search ) &#123; if(max - min &lt;= 1 ) &#123; return menu[middle].id; &#125; // else, continue searching max = middle; &#125; // Else, continue looking for search value else &#123; if ( menu[middle].cost &lt; search ) &#123; // Continue searching right min = middle + 1; &#125; else &#123; // Continue searching left max = middle - 1; &#125; &#125; // Set new middle at halfway point middle = (min + max) &gt;&gt; 1; &#125; // END WHILE, first &gt; last // No price matching 'search' exists in the menu return -1; &#125; public void solve() &#123; // Search menu for a valid pair of prices for(int i = 0; i &lt; n - 1 ; i++) &#123; // Set desired price that will match the cost at index i int search = m - menu[i].cost; // If search &lt; menu[i], then no match exists for that cost because the menu array is sorted if(search &gt;= menu[i].cost) &#123; // Search for the desired value starting at the first index to the right of the flavor at index i int index = binarySearch(i + 1, n - 1, search); // Index of valid second flavor was returned by binary search if( index != -1 ) &#123; System.out.println( Math.min(menu[i].id, index) + " " + Math.max(menu[i].id, index)); break; &#125; // Else, continue looping and check the next value. &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- &gt; 0) &#123; int m = scanner.nextInt(); int n = scanner.nextInt(); IceCream[] menu = new IceCream[n]; // Fill flavor menu and sort for (int i = 0; i &lt; n; i++) &#123; menu[i] = new IceCream(scanner.nextInt(), i + 1); &#125; Solution solution = new Solution(menu, n, m); solution.solve(); &#125; scanner.close(); &#125; &#125; Hash-Map Solution123456789101112131415def flavors(m,a): prices = &#123;&#125; for idx, p in enumerate(a): if m-p in prices: return prices[m-p], idx prices[p] = idx return Nonet = int(input().strip())for a0 in range(t): m = int(input().strip()) n = int(input().strip()) a = list(map(int, input().strip().split(' '))) f1, f2 = flavors(m,a) print(f1+1, f2+1)]]></content>
      <categories>
        <category>Technical Interview</category>
      </categories>
      <tags>
        <tag>Technical Interview</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 24 Game Solver Algorithm and Extensions - a Python Approach 24点算法及延伸 - 一个Python解法]]></title>
    <url>%2F2016%2F07%2F01%2Fthe24Game%2F</url>
    <content type="text"><![CDATA[PrewordBecause I am going to teach at a coding summer camp to middle school kids in Changsha very soon. I have been searching for interesting projects for them to build so they can learn better. And this idea of building a solver for the 24 Game cross my mind. It is rather interesting and takes me actually a lot longer than I expect to finish it. Probably won’t give this to them; maybe as a optional challenge. What is the 24 Game?It is basically a Card game. It originates in China sometime last century. This Chinese game requires skill at mental arithmetic. It has been played in Shanghai at least since the 1960’s and may have originated there, and it is also known in some other cities, for example in Qingdao and Guangzhou. Since the end of the 20th century it has also spread to some places in North America. The basic game for two players will be described first, followed by variations for a larger number of players and extra options. Basically you are given a deck of poker cards and the Jokers are removed. You treat A~10 as 1~10 and J~K as 11~13, (in early versions only A~10 is included) and you have to do some calculations to the four card so the result equals 24. Only basic arithmetics are allowed (+, -, *, / and ( )) and each number can only be used once. For example if the four cards were 2, 3, 6, 9 then possible solutions would be (9+6-3)×2=24, (9-3)×(6-2)=24 or (9×3)-(6÷2)=24. Whoever can tell a correct equation first wins the round. The AlgorithmWas thinking of a iterative approach but code will be too ugly to read. Decide to do a recursive approach. Basically the thinking is to reduce the amount of numbers to calculate to two, so if the output equals 24 it is valid. Take 2 numbers each time and do the 4 operations to reduce to one number and eventually there will be only 2 numbers remaining. Theoretically, this should apply to any amount of numbers and any output to be calculated. For example: There are 4 numbers, take 2 of them and do some calculations so there will be 3 numbers remaining. Now there are 3 numbers, do whatever operations so there will be only 2 numbers remaining. If the 2 can get the output of 24, it is a valid equation; otherwise it is false. The Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# The 24 Game Solver Python Version# @author Xingfan Xiaimport mathPRECISION = 1E-6COUNT_OF_NUMBER = 4NUMBER_TO_BE_CAL = 24g_expression = []g_number = []#inputnumInput = str(input('''enter the numbers you want to solveNote: each number has to be separated by A SPACEyou can enter any numbers you like and any amount of it'''))#initializationg_expression = numInput.split()g_number = [0]*len(g_expression)COUNT_OF_NUMBER = len(g_expression)for i in range(len(g_expression)): g_number[i] = int(g_expression[i])#recursive solverdef solve(n): if(1 == n): if(math.fabs(NUMBER_TO_BE_CAL - g_number[0]) &lt; PRECISION): print("The answer is: " + g_expression[0] + " = 24") return True else: return False else: for i in range(0, n): for j in range(i+1, n): a = g_number[i] b = g_number[j] #********************************** # Move the meaingful forward # answer saved in [i] # number[j]can just be overwritten by the last number # ******************************* g_number[j] = g_number[n - 1] expa = g_expression[i] expb = g_expression[j] g_expression[j] = g_expression[n - 1] # cal a+b g_expression[i] = '(' + expa + '+' + expb + ')' g_number[i] = a + b if ( solve(n - 1) ) : return True # cal a-b g_expression[i] = '(' + expa + '-' + expb + ')' g_number[i] = a - b if ( solve(n - 1) ) : return True # cal b-a g_expression[i] = '(' + expb + '-' + expa + ')' g_number[i] = b - a if ( solve(n - 1) ): return True # cal (a*b) g_expression[i] = '(' + expa + '*' + expb + ')' g_number[i] = a * b if ( solve(n - 1) ): return True # cal (a/b) if (b != 0) : g_expression[i] = '(' + expa + '/' + expb + ')' g_number[i] = a / b if ( solve(n - 1) ) : return True # cal (b/a) if (a != 0) : g_expression[i] = '(' + expb + '/' + expa + ')' g_number[i] = b / a if ( solve(n - 1) ): return True # resume and recursion g_number[i] = a g_number[j] = b g_expression[i] = expa g_expression[j] = expb return False#mainif(not solve(COUNT_OF_NUMBER)): print('no solution') Sample Output 4 Numbers 123456$python3 24Game.pyenter the numbers you want to solveNote: each number has to be separated by A SPACEyou can enter any numbers you like and any amount of it5 5 5 1The answer is: ((5-(1/5))*5) = 24 More than 4 Numbers 123456$python3 24Game.pyenter the numbers you want to solveNote: each number has to be separated by A SPACEyou can enter any numbers you like and any amount of it9 9 9 9 7 7 7 7 3 2 5 6 1 3 8The answer is: (((((((((((9+9)+8)+3)+1)+6)+5)+2)+3)+7)+7)/((9/(7-9))+7)) = 24 ReferenceRules of Twenty Four]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tutorial</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Research for Stoooges Wiki Framework Selection]]></title>
    <url>%2F2016%2F06%2F21%2FWikiFrameWorks%2F</url>
    <content type="text"><![CDATA[大型框架全能但庞大Media Wiki (Demo: 萌娘百科, WikiPedia)简要：大型企业级框架，有些臃肿。Wikipedia就用了这个框架，不过可以在其基础上进行很大程度的自定义。主要基于PHP, MySQL。 优点： 提供了非常完整的一套框架体系， 运行环境要求很低,架设过程简洁,即使新手也可以迅速建立自己的站点 。 支持相当程度的自定义。 API HOoks Parser Functions SKins Special Pages Tag Extension 应用扩展制作简单：不需要修改PHP文件，PHP程序员可直接写扩展进行挂载，非常方便。 适合高配置高抗压：网站访问量越大、服务器配置越高越能体现Mediawiki性能，因为Mediawiki已经为程序准备好迎接高强度体验。 mediawiki的功能非常丰富,支持多语言版本,充分满足知识站点的需要 。 有大量插件可以使用。 相当大的开发社区。 运用广，目前用的最多的wiki框架；并且在不停开发。 中文支持度非常好。 缺点： 低配置运行慢：Mediawiki很多功能都是为高访问量抗压设置，而如果只是文件缓存功能等，在低配置上和小访问量网站上会效果一般。 服务端兼容性不佳。 文章编辑代码有一些学习曲线，编辑新文章比较复杂；一般人不学习之前没法编辑。 总结：仍然是目前最好的框架，但是没有可视化编辑器（好像有插件可以解决此问题）。 XWiki (Demo)简要：基于Java的开源框架。有10年以上的开发历史，有800多个插件。 优点： 界面简洁，界面风格可配置性很强，无需在页面代码中书写配置脚本。 插入宏或者插件/链接等超级容易，简单易用。 缺点： 中文支持度很差。中文界面很差，搜索准确率很低。 许多配置功能都需要代码层面的调试。 无可视化编辑器。（对小白用户不友好） 总结：功能多但是相当难用，中文支持度还差不建议使用。 BitWeaver简要：和Media Wiki一样是个全能框架。基本该有的功能都有。 优点： Wiki, Blog, Post什么的功能 非常简单的主题自定义。 强大的CSS功能。 安装比较简单。 缺点： 据有些用户说相当慢。 还是没有可视化编辑器。 预加载的功能很多，需要手动关闭不需要并且会拖慢加载速度的功能。 Markdown Based框架：小型高速但功能受限Gitit (Demo Site)简要：基于Haskell 和 Pandoc 的 Wiki。支持大量不同方式的输入。 优点： 因为是基于Pandoc进行标记。所以支持大量标准的格式：Markdown. RST, LaTeX, etc Markdown集成了TeXmath, 有完善的数学公式支持。 简洁的界面。 缺点： 无可视化编辑器。（对小白用户不友好） 框架较为简单，适合做简单的wiki，缺乏大型wiki的功能性。 总结：因为是留学百科似乎不需要这么多输入格式标准，不过markdown输入仍然算是相当友好的编辑方式。 Simiki (Demo)简要：基于Python的Wiki Framework。 优点: Setup简单快捷。 能按Category归纳文档。 使用Markdown编辑。 页面结构模仿mediawiki，有这样的需求的话推荐Simiki。 提供CLI工具支持。 缺点： 不提供搜索支持。可以尝试使用微搜索等第三方服务进行站内搜索。 不详。 总结：纳入备选方案。 MDWIKI (Demo)简要：基于JS的Wiki Framework. 优点: 完全基于HTML5和JavaScript，无其他dependency 需求。 使用Markdown编辑。 基于BootStrap3和jQuery的跨浏览器支持和响应式布局。 页面简洁，和传统的wiki页面布局不太一样；但是我个人比较喜欢这种Manual风格。 提供BootStrap自订主题，并支持所有Bootswatch主题。 缺点： 不提供搜索支持。可以尝试使用微搜索等第三方服务进行站内搜索。 不详。 总结：纳入备选方案。 Realms.io简要：基于Python和NodeJS的Wiki Framework. 优点: 完全基于HTML5和JavaScript，无其他dependency 需求。 使用Markdown编辑，并提供了内置编辑器（可以实时预览输出效果）。 基于BootStrap3和jQuery的跨浏览器支持和响应式布局。 页面风格比较码农风，好像目前还没有目录功能。。 提供合作功能。 提供历史记录。 缺点： 不详。 总结：纳入备选方案。 Gollum简要：基于Git和Ruby的Wiki Framework，基本上就像一个git repo。 优点: 支持2种markup语言：ROC和Markdown。 页面风格很有Github风格; Github 就用这个framework来维护他们的wiki功能。 提供多种hosting方式。 提供历史记录。 提供搜索。 缺点： 不是静态，不过可能可以通过这个Package来解决：gollum-site。 总结：纳入备选方案。 附录:符合要求的框架引擎比较]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python a Dummy Guide]]></title>
    <url>%2F2016%2F02%2F22%2Fpython%2F</url>
    <content type="text"><![CDATA[A Dummy Guide to PythonDay One: Complete IntroductionWhat is Python?Python is a language designed to write computer programs. You may or may not hear of many popular programming languages. For example, there is C language [One of the hardest language to learn] , Java [which is insanely popular but also pretty hard] , Basic [the Language for beginners] , and JavaScript [Designed for web developing]. What kind of language is Python?To start, we have to talk about programming language first. Any programming language is designed to tell the computer to do its job like downloading a mp3, editing text. However, the CPU inside the core of computer only recognizes machine code which is basically 1 and 0s. So, even though there are huge differences between different kinds of programming languages. They, eventually, have to be translated as machine code that could be executed by CPU. Different programming language requires different loads of code to be written. For example, to write for the same task, maybe you have to write 1000 lines of C and 500 lines ofJava but you only needs 100 lines of Python. So Python is a very high-level language. So you may ask, wow, only $\frac{1}{10}$lines of code written in C. Why don’t we write everything in Python? However, with fewer lines of code, it requires more time to compute. For example, C program may only take 1s,Java 2s but Python may need 10s. So is it to say that lower-level languages are easier and high level language are harder? Superficially yes! However, in very advance abstract computing, high-level Python is pretty hard to learn as well! However, if we take those advance stuff out of the context. Then, yes, Python is easy to learn for beginners and it’s very handy for small scripts. Giants like Google and Facebook use it everywhere as well. So what you can do with Python exactly? You can write daily tasks like doing daily backup of your music library; you can write a website with it (Youtube is written largely in Python); you can make a backend of online games. In short, you can a lot with Python A Better Intro to PythonPython is developed by Guido Van Possum during Xmas 1989. And he built it just to pass time, being too bored at home for Xmas. Application Language PythonThere are around 600 programming languages; and the popular ones you can count are under 20. The most popular programming languages in last 10 years are shown in the diagram below: Overall, these programming languages have their own pros and cons. For example, C can be used to write operating system and other languages that work very closely with hardwares. C is suitable to build programs that are speed-hungry, trying to squeeze every last bit of hardware power. In contrast, Python is the high level language that is required to build application software. Libraries for High-level Languages like PythonWhen you are starting real software development, apart from writing codes, there are also a lot of elementary prewritten stuff for you to use, to speed up your development. For example, you were to write a email client, if you start from writing codes for the most low-level network protocols, you probably can’t write any shit in a year or two. However, higher level languages are usually packaged with a library that provides all these features for you to use. For example, SMTP library for email protocols, GUI library for desktop environment. To build your application upon these, an adequate developer can write a simple email client in a few days. Python proves us with this very complete code library, it covers network, file, GUI, database, text and other whole lot of content and these are nicely called as “batteries included”. For Python development, not everything has to start from scratch. You are more than welcome to what Python has for you. These libraries are usually very well written, commented and more efficient than your code if you were to write it on your own. Apart from the built-in libraries, there are a lot of third-party libraries developed by other developers free for you to use. Of course, you can also write libraries for others to use. What are Python suitable for?When Guido develops Python, he defines it as “elegant”, “precise” and “simple”. So python programs looks very simple to understand but it also have the capacity to write for very complicated needs. In short, python’s philosophy is simple and elegant. Write fewer codes, write simpler codes. If someone is showing off his difficult and complicate code, laugh at him! So what exactly are python suitable for? Web apps. Including backend services and websites, etc Many daily simple scripts that speed up your workflows. Wrap around applications developed in other languages and make it easier to use. Lastly, we will talk about python’s shortcomings. Python is slow.Compared to C, python is very slow. Because python is a interpret language. Your code is translated to machine code line by line when your code is executing. This translation is very slow and time-consuming. C applications are pre-complied to machine code understandable by CPU before it can execute. So C is very fast. However, a lot of applications don’t need to be fast. Because users can’t feel the difference. For example, when you develop a application to download mp3 , the C application may take 0.001s and the python application may take 0.01s, 10 times slower. However, Internet are slower, it requires 5 seconds. Can the user feel the difference between 5.001s and 5.01s? It’s like driving F1 race car in a traffic jam. Even though F1 cars can run at 400kph; because of the jam, it moves like a snail, slower than 20kph. Not better than taking a taxi which can only run maybe 100kph at best. Python could not be encrypted.If you were to publish your python program, you are publishing its source code. This is very different from C. C doesn’t require publishing source code for it to be executed. You only need to publish the compiled machine code (the ****.exe) And it is very impossible for people to reverse engineer the source code from compiled machine code. For all the compile language, there is no such a problem. For interpret language, you have to publish the source code. This shortcoming is only limited when you have to sell your software to others to make money. The good news is the Internet time is coming and selling license is less and less. More and more developers are selling services and this doesn’t require them to give their source code to any one. Also, the open-source wave and the Internet spirit of free and open is everywhere over the Internet. There are countless beautiful codes like linux. The big companies who are reluctant to give their codes are often because their codes are so bad. If open-sourced, no one want to use their product any more. There are also some small shortcomings of python. But it’s trivial and we won’t count it in this course. Install Python]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dummy Guide：如何使用Shadowsocks科学上网]]></title>
    <url>%2F2016%2F02%2F02%2FIntroGuideToSS%2F</url>
    <content type="text"><![CDATA[Requirement:海外服务器一台，一些动手动脑能力 服务器配置: 首先需要一台海外服务器， 推荐使用DigitalOcean (这里用的是我的Referral链接，注册即可获得10刀Credit) 的5刀一月服务器。 P.S. 如果有Edu结尾的邮箱可以去申请Github Student Developer Pack。里面包含了十几个开发工具和价值50刀的DigitalOcean Credit链接 (以前有100刀)。 P.S. Edu.cn是无效的。 之后就可以在Digital Ocean建Droplet。因为仅仅是用于翻墙，5刀的Ubuntu plan即可。因为翻墙对服务器压力很小，多余的资源可以原来建个人主页；建议在one-click apps中选择LAMP，可以省去很多大量运行环境的设置或是ghost来做简单的独立博客。 要连接这个远程的虚拟主机的话推荐使用ssh连接。 MAC端的话使用Terminal即可： 1ssh root@yourhostIP Windows端的话需要使用额外的第三方程序putty来进行对虚拟主机的连接。 连上后需要使用建立droplet后发到注册邮箱的密码来登入，并且需要重设新密码。P.S. 没用过linux的用户注意linux输入密码时并不显示任何字符。 成功进入主机的terminal界面时就可以开始Shadowsocks的配置了。 12apt-get install python-pippip install shadowsocks 然后创建Shadowsocks配置文件shadowsocks.json 1nano /etc/shadowsocks.json 内容如下填写 12345678&#123; "server":"1.2.3.4", // 服务器IP "server_port":, // 对外提供服务的端口 "local_port":, //随意填写，一般8080 "password":"your password", "timeout":, "method":"rc4-md5"&#125; Tip: 加密方式推荐使用rc4-md5，因为 RC4 比 AES 速度快好几倍，并修复了老版本RC4加密的安全漏洞；如果用在路由器上会带来显著性能提升。 创建完配置文件就可以开始启用shadowsocks了。 123456789101112//前台启动ssserver -c /etc/shadowsocks.json//后台运行ssserver -c /etc/shadowsocks.json -d start # 启动ssserver -c /etc/shadowsocks.json -d stop # 停止//持续运行nohup ssserver -c /etc/shadowsocks/config.json &amp;gt; log &amp;amp;//开机自启动/usr/local/bin/ssserver -c /etc/shadowsocks/config.json 客户端配置MAC GUI Client:ShadowsocksX V2.6.3 Windows GUI Client:Shadowsocks-win V2.5.6 客户端配置比较基础，在此不赘述了（其实是因为我太懒了w）。可以参考这篇文章：ShadowSocks—科学上网之瑞士军刀 如果对翻墙速度不是很满意，可以尝试使用一些加速服务；虽然并不会有太大的提高。请参考这篇文章：科学上网之 Shadowsocks 安装及优化加速]]></content>
      <categories>
        <category>GFW</category>
      </categories>
      <tags>
        <tag>GFW</tag>
        <tag>SS</tag>
        <tag>Linux</tag>
        <tag>Digital Ocean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2016%2F02%2F01%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[What I am going to do with this blog? Record interesting stuffs. Discuss interesting issues. Share thoughts. Keep learning.]]></content>
      <categories>
        <category>Miscellaneous</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arth_final]]></title>
    <url>%2F2015%2F11%2F17%2Farth-final%2F</url>
    <content type="text"><![CDATA[ARTH FinalFormat Identification 5x ​Comparison 4x Essay Prehistoric 1.11 Hall of Bulls, Lascaux Cave (France), c. 15000 BCE depicts cows, bulks, horses and deer along the natural ledges of the rock the most characteristic features have been emphasized horns, eyes, hooves are shown as seen from the front, yet heads and bodies are rendered in profile in a system known as a composite pose 1.20-22 Stonehenge, Salisbury Plain (England), c. 2900-1500 BCE Arthurian literature: Merlin did it Post and lintel construction Lines up with solstices -&gt; calendar The site is important Avenue found from Stonehenge to river River is a spiritual transition from life(Woodhenge) to death(Stonehenge) Ancient Near Eastern2.15 Stele of Hammurabi, from Sippar, Babylon (Iraq), diorite, c. 1792-1750 BCE Code of injustice Hammurabi: I have communication with God that no one has Most famous are instances when punishments are specifically tailored to fit crimes—an eye for an eye, a tooth for a tooth, a broken bone for a broken bone. Punishments are based on the wealth, class, and gender of the parties—the rights of the wealthy are favored over the poor, citizens over slaves, men over women. Although some of the punishments may seem excessive today, Hammurabi was breaking new ground by regulating laws and punishments rather than leaving them to the whims of rulers or officials. 2.17 Assurnasirpal II Killing Lions, Palace at Nimrud (Iraq), c. 875-860 BCE Assurnasirpal II stands in a chariot pulled by galloping horses and draws his bow against an attacking lion, advancing from the rear with arrows already protruding from its body. Another expiring beast collapses on the ground under the horses. This was prob- ably a ceremonial hunt, in which the king, protected by men with swords and shields, rode back and forth killing animals as they were released one by one into an enclosed area. The imme- diacy of this image marks a shift in Mesopotamian art, away from a sense of timeless solemnity, and toward a more dramatic, even emotional, involvement with the event portrayed. Demonstrates power of ruler. 2.22 Ishtar Gate, Babylon (Iraq), glazed brick, c. 575 BCE The Ishtar Gate is decorated with tiers of dragons (with the head and body of a snake, the forelegs of a lion, and the hind legs of a bird of prey) that were sacred to Marduk, with bulls associated with Adad, the storm god, and with lions associated with Ishtar. Now reconstructed in a Berlin museum, it is installed next to a panel from the throne room in Nebuchadnezzar’s nearby palace, in which lions walk beneath stylized palm trees. glazed - so color survived Saddam Hussein built a palace on a site, now with graffiti conservation nightmare keep it or tear it down they kept it as it is Style formal how does something look communities with shared characteristics have similar styles Stylistic analysis: form -&gt; hypothesis on culture and origin EgyptianEarly Dynastic Egyptp. 52 Palette of Narmer, schist, Hierakonpolis, c. 2950 BCE Phonetic hieroglyphs centered at the topof each side of the palette name the king: a horizontal fish (nar) above a vertical chisel (mer). A depiction of the royal palace—seen simultaneously from above, as a groundplan, and frontally, as a façade (front wall of a building)—surrounds Narmer’s name to signify that he is king. The royal processioninspects two rows ofdecapitated enemies,their heads neatlytucked between their feet. 3.3 Step Pyramid of Djoser, Saqqara, limestone, c. 2600 BCE Although the step pyramid resembles the ziggurats of Mesopota- mia, it differs in both meaning (signifying a stairway to the sun god Ra) and purpose (protecting a tomb). Old Kingdom Egypt3.4-5 Great Pyramids (of Khufu, Khafre &amp; Menkaure), Giza, c. 2575-2450 BCE The site was carefully planned to follow the sun’s east–west path. Next to each of the pyramids was a funerary temple con- nected by a causeway—an elevated and enclosed pathway or cor- ridor—to a valley temple on the bank of the Nile (see FIG. 3–5). When a king died, his body was embalmed and ferried west across the Nile from the royal palace to his valley temple, where it was received with elaborate ceremonies. 3.8 Khafre, from Valley Temple of Khafra, Giza, c. 2500 BCE High relief. Pharaoh’s characteristics: fake beard, bull tail, striped headdress Egypt continuous stylistic culture emphasis on tradition New Kingdom Egypt3.1 Funerary Mask of Tutankhamun, c. 1327 BCE 3.18-20 Great Temple of Amun, Karnak, 1579-1075 BCE 3.26 Akhenaten and His Family, limestone, c. 1345 BCE – Amarna Period No longre a ka statue, a fleeting momnet rather than forever seated, casual solar deity headdress blown by wind -&gt; momentary 3.35 Judgment of Hunefer before Osiris, from a Book of the Dead, papyrus, c. 1285 BCE GreekArchaic Period:5.18 Metropolitan Kouros, marble, c. 600 BCE Transition to —&gt; Anonymos Kouros(c 530) —&gt; Doryphoros(c 450) Muscle more detailed Cibtrapposto “in opposition” Dynamism, yet still poised Less stylization, more naturalism 5.1 Ajax and Achilles Playing a Game, by Exekias, c. 535 BCE Two heroes waiting in the war Ajax(Right): a Greek hero, the second best, same Achilles’s body and armor from Trojans Ajax grabbing the spear, heal off the ground Black figure comes first, then red figure High Classical Period5.36 Parthenon, Acropolis, Athens, by Iktinos &amp; Kallikrates, c. 447-432 BCE 5.42 Spear-Bearer (Doryphoros), by Polykleitos, c. 450-440 BCE (marble copy of bronze) Late Classical Period5.53 Aphrodite of Knidos, by Praxiteles, c. 350 BCE (marble copy of marble) Hellenistic5.62 Altar from Pergamon, c. 175-150 BCE, marble 5.63 Athena Attacking the Giants, Altar from Pergamon, c. 175-150 BCE, marble 5.64 Laocoön and His Sons, marble, 1st century BCE Roman6.14 Patrician Carrying Ancestor Busts, late 1st century BCE. 6.20-22 Ara Pacis Augustae, 13-9 BCE, marble, Rome 6.47-48 Column of Trajan, 113-116 CE, marble, Rome 6.49-52 Pantheon, c. 118-128 CE, Rome 6.65-66 Arch of Constantine, 312-315 CE, marble, Rome Early Christian7.17 Sarcophagus of Junius Bassus, c. 359, marble 7.18-20 Oratory of Galla Placidia, c. 425-426, Ravenna (Italy) Byzantine8.2-4 Church of Hagia Sophia, Anthemius &amp; Isidorus, 532-537, Istanbul (Turkey) 8.14 Virgin and Child with Saints and Angels, late 6th century, encaustic on wood 8.21-22 Christ Pantokrator &amp; Crucifixion, Church of the Dormition, c. 1100, Daphni (Greece) Islamic9.2 The Kaaba, Mecca (Saudi Arabia), before 630 9.6-8 Great Mosque, Cordoba (Spain), begun 785 9.15 Court of the Lions, Alhambra, Granada (Spain), 1354-1391 9.17 Tile Mosaic Mihrab, Isfahan (Iran), 1354 South &amp; Southeast Asia10.6 Lion Capital, from an Ashokan pillar at Sarnath, India, c. 250 BCE 10.8 Great Stupa, Sanchi, founded 3rd century BCE, enlarged c. 150-50 BCE 10.10 Chaitya Hall, Karle, India, 1st century BCE-1st century CE 10.12 Standing Buddha, Gandhara, Pakistan, c. 200 CE 10.13 Buddha and Attendants, Mathura, India, c. 100 CE 10.15 Vishnu on the Cosmic Waters, Vishnu Temple, Deogarh, India, c. 530 CE 10.27 Kandariya Mahadeva Temple, Khajuraho, India, c. 1000 CE 10.30 Rajarajeshavra Temple of Shiva, Thanjavur, India, 1010 CE 10.31 Shiva Nataraja, c. 1050 CE Chinese Buddhism11.12 Seated Buddha, cave 20, Yungang, c. 460 CE 11.13 Altar to Amitabha Buddha, 593, bronze 11.20 Seated Guanyin Bodhisattva, c. 1100 Japanese Shinto &amp; Buddhism12.3 Main Hall, Inner Shrine, Ise, (near Tokyo), rebuilt 2013 12.4 Horyu-ji Compound (near Nara), 7th century 12.5 Hungry Tigress Jataka, panel from the Tamamushi Shrine, Horyu-ji, c. 650 12.6 Tori Busshi, Shaka Triad, Horyu-ji, c. 623 12.11 Phoenix Hall, Byodo-in, Uji (near Kyoto), c. 1053 12.12 Jocho, Amida Buddha, Byodo-in, c. 1053 CE 12.16 Kuya Preaching, before 1207 Mesoamerican13.1 Offering 4, La Venta (Mexico), c. 900-400 BCE – Olmec 13.3 Colossal Head, San Lorenzo (Mexico), c. 1200-900 BCE, basalt – Olmec 13.4 Ceremonial Center of Teotihuacan (Mexico), c. 100-650 CE p. 394 Shield Jaguar and Lady Xok, Yaxchilan (Mexico), 725 – Mayan 13.13 Cylindrical Vessel with Ballgame Scene, c. 600-800 – Mayan Early Medieval Art15.1 Chi-rho-iota Page, Book of Kells, Hiberno-Saxon, c. 800 15.4 Hinged Clasp, from the Sutton Hoo burial ship, Anglo-Saxon, 7th c 15.6 Initial Page, Lindisfarne Gospels, Anglo-Saxon, c. 720 Romanesque16.9 Abbey Church of Notre-Dame, Fontenay (France), 1139-47 16.7 Reliquary Statue of Sainte Foy, Abbey Church of Conques (France), c. 900 p. 483 Last Judgment Tympanum, west portal, Church of Saint-Lazare, Autun (France), c. 1130 16.29-30 Bayeux Embroidery, Norman-Anglo-Saxon, c. 1070 Gothic17.2 Abbey Church of Saint-Denis, near Paris (France), 1140-44 17.4 West façade, Chartres Cathedral (France), begun c. 1134; rebuilt after 1194 fire 17.5 Royal Portal, West façade, Chartres Cathedral (France), c. 1150 17.9 Nave, Chartres Cathedral (France), c. 1194-1220 17.13 West Façade, Reims Cathedral (France), begun c. 1225 17.15 Nave, Reims Cathedral (France), begun c. 1211 14th-Century (Late Gothic)18.1&amp;15 Ambrogio Lorenzetti, Effects of Good Government, fresco, Palazzo Pubblico, 1339 18.7-9 Giotto, wall frescoes, Arena (Scrovegni) Chapel, Padua, 1305 18.10-12 Duccio, Maestà, Siena Cathedral, 1310, tempera]]></content>
  </entry>
</search>
